{div open id="intro"}

{{:https://computation.llnl.gov/casc/sundials/main.html}Sundials} is a
collection of five numerical solvers: CVODE,  CVODES, IDA, IDAS, and KINSOL.
It is written by Alan Hindmarsh, Radu Serban, and Carol Woodward at the {e
Center for Applied Scientific Computing, Lawrence Livermore National
Laboratory} with the contributions from Peter Brown, Scott Cohen, Aaron
Collier, Keith Grant, Steven Lee, Dan Reynolds, Dan Shumaker, and Allan
Taylor.

This OCaml interface was written by {{:http://www.tbrk.org}Timothy Bourke}
({{:http://www.inria.fr}Inria}/{{:http://www.di.ens.fr/}ENS}),
{{:http://www.owlnet.rice.edu/~ji2/}Jun Inoue}
({{:http://www.inria.fr}Inria}/{{:http://www.di.ens.fr/}ENS}),
and
{{:http://www.di.ens.fr/~pouzet/}Marc Pouzet}
({{:http://www.upmc.fr/}UPMC}/{{:http://www.inria.fr/}Inria}/{{:http://www.di.ens.fr/}ENS}).
It provides a complete OCaml interface to Sundials version {b {var version}}.

The structure of this interface mostly follows that of the original library,
both for ease of reading the existing documentation and for converting
existing source code, but several changes have been made for programming
convenience, namely:
- solver sessions are mostly configured via algebraic data types
  rather than multiple function calls;
- error conditions are signalled by exceptions not return codes
  (including in user-supplied callback routines);
- closures (partial applications of functions) are used to
  share user data between callback routines, and;
- explicit free commands are not necessary since OCaml is a garbage-collected
  language.

Functions have been renamed according to a regular scheme. Leading {e
module identifier} are replaced by module paths, words
beginning with an uppercase letter are separated by underscores, and put
into lowercase. For instance, [IdaSetErrHandlerFn], becomes
{!Ida.set_err_handler_fn}, and [CVSpilsSetJacTimesVecFn] becomes
{!Cvode.Spils.set_jac_times_vec_fn}.
Constants are replaced by variant types in most cases.
They are renamed by conversion to {e CamlCase} and the removal of
underscores.
For instance, [PREC_NONE] becomes {!Spils.PrecNone}.

Rather than try to duplicate or replace the comprehensive
{{:https://computation.llnl.gov/casc/sundials/documentation/documentation.html}
Sundials user manuals}, this documentation provides brief summaries, taken
directly or adapted from the manual, with hyperlinks back to the original
text.

{2:nvector Nvectors}

Sundials defines an abstract interface for vectors and provides default
serial and parallel instantiations.
The OCaml interface defines likewise a generic
{!Sundials.nvector} type whose type arguments indicate the underlying {e
data} and {e kind}—one of {!Nvector_serial.kind}, {!Nvector_parallel.kind},
or {!Nvector_custom.kind}.
The {!Sundials.unvec} function gives direct access to the underlying data.

The interface to serial nvectors, {!Nvector_serial}, is based on
{{:http://caml.inria.fr/pub/docs/manual-ocaml/libref/Bigarray.html}Bigarrays}.
These arrays are manipulated directly, i.e., with no additional overhead,
within the solver by the original low-level serial nvector operations
(see {!Nvector.NVECTOR_OPS}).
The same low-level operations can be called from OCaml
({!Nvector_serial.Ops}), as can equivalent reimplementations on the
underlying data ({!Nvector_serial.DataOps}).

The interface to parallel nvectors, {!Nvector_parallel}, is also based on
{{:http://caml.inria.fr/pub/docs/manual-ocaml/libref/Bigarray.html}Bigarrays}.
It exploits the {{:https://forge.ocamlcore.org/projects/ocamlmpi/}OCaml/MPI}
library. Parallel nvectors are only available when Sundials/ML is configured
to use MPI, as described {{:install}below}.

Besides these two standard implementations, it is also possible to define
new nvector implementations through {!Nvector_custom} by providing low-level
operations on an underlying datatype. A demonstration of this feature on
{!float array}s is provided in {!Nvector_array}. Custom nvectors suffer two
disadvantages compared to the standard nvector implementations. First, each
low-level operation incurs the cost of a callback into OCaml. Second, of all
the provided linear solvers, only {!Cvode.Diag} could be used; although
custom solvers could be implemented through {!Cvode.Alternate},
{!Ida.Alternate}, and {!Kinsol.Alternate}.

{2:linsolv Linear Solvers}

TODO: write this

{2:modules Modules}

{!modules: Sundials}
{!modules: Dls Spils}
{!modules: Nvector Nvector_serial Nvector_parallel Nvector_custom Nvector_array}
{!modules: Cvode Cvode_bbd Cvodes Cvodes_bbd}
{!modules: Ida Ida_bbd Idas Idas_bbd}
{!modules: Kinsol Kinsol_bbd}

{2:install Dependencies and Installation}

The dependencies of Sundials/ML are
- {{:http://caml.inria.fr/ocaml/}OCaml} {b 3.12.1 or greater},
- {{:http://computation.llnl.gov/casc/sundials/}Sundials} {b {var version}},
- {e Optionally}:
  {{:https://forge.ocamlcore.org/projects/ocamlmpi/}OCaml/MPI} {b 1.01}.

The [configure] script detects whether Sundials was built with lapack
support, which is required for the [lapack_dense] and [lapack_band]
solvers (like {!Cvode.Dls.lapack_dense}).
The {!Sundials.blas_lapack_supported} value indicates whether these
solvers are available.

Parallel nvectors and Band-Block-Diagonal (BBD) solvers are {e
only} built if explicitly requested (via [--enable-mpi]).

{3:opam Opam}

Opam is the easiest way to install the library.

TODO: write instructions, how to get the different features, etc.

{3:build From source}

Building from source is a two step process:
{ol
    {- run [configure] to find and check dependencies, and}
    {- run [make install] to build and install the library.}
}

The choices made by the configure script can be influenced by arguments
(like [--enable-mpi] and [--prefix=...]) and variables (like
[OCAMLROOT=...]). Type [configure --help] for detailed information.

OCaml reimplementations of the standard Sundials examples are provided in
the [examples/] subdirectory.
The library's behaviour can be tested via [make tests.opt.log] which runs the OCaml
versions and compares their outputs against those of the original C
versions.
The library's performance can be analyzed via [make perf.opt.log] which
produces the graph explained {{:#performance}below}.

{2:compilation Compiling programs}

TODO: Programs can be compiled using the
[-I +sundials] option and including [unix.cma] (or [.cmxa]),
[bigarray.cma] (or [.cmxa]) and [sundials_ida.cma] (or [.cmxa]), for example:
{[ocamlc -o myprogram -I +sundials unix.cma bigarray.cma sundials_ida.cma myprogram.ml]}
or:
{[ocamlopt -o myprogram -I +sundials unix.cmxa bigarray.cmxa sundials_ida.cmxa myprogram.ml]}

TODO: compiling with and without sensitivity.
TODO: compiling with and without mpi.

{2:performance Performance}

An interface like Sundials/ML inevitably adds execution overhead: there is
extra code to execute at each call. But, how significant is this cost? And,
more broadly, how does the performance of OCaml compare to that of C for
programs that use numerical solvers?

These questions are not easy to answer. As a first attempt, the bars in
the following graph show the ratios of the execution times of the Sundials
examples reimplemented in OCaml to the original versions in C, i.e., a
value of 2 (on the axis at left) means an OCaml version that is
twice as slow.

{img perf.opt.png}

The graph suggests that the OCaml versions are rarely more than twice as
slow as the original ones and that they are often around or less than 50%
slower.
The [*_custom] example ({color #a1d99b light green}) uses custom nvectors
with low-level operations in OCaml and the [*_alt] examples ({color #31a354
dark green}) use linear solvers implemented in OCaml.

Such a conclusion seems reasonable as a first approximation, but several
details of the analysis process and individual results show that the real
situation is less clear-cut. For one, the running times of most of the
examples are so short that accurate profiling is not possible (i.e.,
{{:http://pubs.opengroup.org/onlinepubs/9699919799/utilities/time.html}time}
and {{:https://sourceware.org/binutils/docs/gprof/}gprof} simply show 0
seconds).
The figures in the graph were obtained by modifying the examples to
repeatedly execute their [main] functions.
The number of repetitions varies per example since otherwise the slower
examples take too long.
The timings indicated by the crosses and the axis at right are calculated by
dividing the measurement made for each C version by the number of repetitions.
All but six of the serial examples ({color #de2d26 red}) run so fast that 
comparisons are made based on tens, or usually hundreds of repetitions and this
seems to amplify factors other than the interface overhead.
For instance, some examples spend a good fraction of their time in [printf],
and we were able to lower their ratios by instead using [print_string] and
[print_int].

The parallel examples ({color #fc9272 lighter red}) all have longer runtimes
and the results shown are obtained without iterating.

For many of the examples with longer running times, the ratio OCaml/C is
close to 1.

TODO: performance tips for programs: a) type annotations for vectors; b)
avoid slice and sub; c) unwrap and use array access for matrices.

TODO: Thanks to OCaml's optimizations for (unboxed) floats and tight loops,
and also to the MPI and Bigarray libraries.

TODO: profile with -O3 and CHECK_MATRIX_ACCESS, etc. = 0.

Summarize: slower but not by too much, must factor in with the other
advantages of using OCaml (memory management, bounds checking, etc.), easy
to combine with symbolic code.

{2:refs References}

A. C. Hindmarsh, P. N. Brown, K. E. Grant, S. L. Lee, R. Serban, D. E.
Shumaker, and C. S. Woodward, “{{:http://computation.llnl.gov/casc/nsde/pubs/toms_sundials.pdf}{b SUNDIALS: Suite of Nonlinear and
Differential/Algebraic Equation Solvers}},” ACM Transactions on Mathematical
Software, 31(3), pp. 363-396, 2005.

{2:acks Acknowledgements}

TODO: acknowledge {{:https://itea3.org/project/modrio.html}Modrio} for (partial) funding.

TODO: Bigarray and mpi libraries.
TODO: Jonathan Protzenko's {{:http://www.xulforum.org/files/ocamlcss/style.css}CSS stylesheet} for OCamldoc
TODO: {{:http://www.mathjax.org}MathJax} for mathematics rendering.

{2:indexes Indexes}

{!indexlist}
{div close}
