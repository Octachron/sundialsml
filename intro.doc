{div open id="intro"}

{{:https://computation.llnl.gov/casc/sundials/main.html}Sundials} is a
collection of five numerical solvers: CVODE,  CVODES, IDA, IDAS, and KINSOL.
It is written by Alan Hindmarsh, Radu Serban, and Carol Woodward at the {e
Center for Applied Scientific Computing, Lawrence Livermore National
Laboratory} with the contributions from Peter Brown, Scott Cohen, Aaron
Collier, Keith Grant, Steven Lee, Dan Reynolds, Dan Shumaker, and Allan
Taylor.

This OCaml interface was written by {{:http://www.tbrk.org}Timothy Bourke}
({{:http://www.inria.fr}Inria}/{{:http://www.di.ens.fr/}ENS}),
{{:http://www.owlnet.rice.edu/~ji2/}Jun Inoue}
({{:http://www.inria.fr}Inria}/{{:http://www.di.ens.fr/}ENS}),
and
{{:http://www.di.ens.fr/~pouzet/}Marc Pouzet}
({{:http://www.upmc.fr/}UPMC}/{{:http://www.inria.fr/}Inria}/{{:http://www.di.ens.fr/}ENS}).
It provides a complete OCaml interface to Sundials version {b {var version}}.

The structure of this interface mostly follows that of the original library,
both for ease of reading the existing documentation and for converting
existing source code, but several changes have been made for programming
convenience, namely:
- solver sessions are mostly configured through algebraic data types
  rather than through multiple function calls,
- error conditions are signalled by exceptions rather than return codes
  (including in user-supplied callback routines),
- closures (partial applications of higher-order functions) are used to
  share user data between callback routines, and,
- explicit free commands are not necessary nor provided since OCaml is a
  garbage-collected language.

Functions have been renamed according to a regular scheme. The leading {e
module identifier} is removed and replaced with a module path, words
beginning with an uppercase letter are separated by underscores, and only
lowercase letters are used. For instance, [IdaSetErrHandlerFn], becomes
{!Ida.set_err_handler_fn}, and [CVSpilsSetJacTimesVecFn] becomes
{!Cvode.Spils.set_jac_times_vec_fn}.
Constants have been replaced by variant types in most cases.
They have also been renamed by converting them to {e CamlCase} and removing
underscores.
For instance, [PREC_NONE] becomes {!Spils.PrecNone}.

Rather than try to duplicate or replace the comprehensive
{{:https://computation.llnl.gov/casc/sundials/documentation/documentation.html}
Sundials user manuals}, this documentation provides brief summaries, taken
directly or adapted from the manual, with hyperlinks back to the original
function descriptions.

{2:nvector Nvectors}

Sundials defines an abstract interface for vectors and provides
implementations for serial and parallel vectors. The OCaml version defines a
generic {!Sundials.nvector} type with type arguments indicating the
underlying data and kind ({!Nvector_serial.kind}, {!Nvector_parallel.kind},
and {!Nvector_custom.kind}).

The data underlying serial ({!Nvector_serial.t}) and parallel
({!Nvector_parallel.t}) nvectors is passed between Sundials
and OCaml programs using
{{:http://caml.inria.fr/pub/docs/manual-ocaml/libref/Bigarray.html}Bigarrays}.
These vectors are manipulated directly within the
solver using the original low-level vector operations (cloning, linear sums,
adding constants, and etcetera; see {!Nvector.NVECTOR_OPS}).
There are no direct interfaces to these operations from OCaml, but
equivalent reimplementations are provided ({!Nvector_serial.DataOps}).

There are also mechanisms for defining new vector implementations using
records of imperative ({!Nvector_custom}) or pure functions
({!Nvector_custom.Immutable}). A vector implementation for standard OCaml
arrays of floats is provided as an example ({!Nvector_array}). These
abstract nvectors may be useful for small examples, prototyping, or
debugging, but native serial (and parallel) nvectors have two important
advantages:
+ {e efficiency}, since the low-level vector operations are implemented
directly in C (rather than as C stubs around OCaml callbacks) and memory
management is simpler, and,
+ {e support} for all linear solvers, since some linear solvers do not
support abstract nvectors,

{2:modules Modules}

The top level {!Sundials} module provides some utility routines for dealing
with arrays of floats and integers, and for accessing certain constants
(like {!Sundials.big_real} and {!Sundials.unit_roundoff}).

{!modules: Sundials}
{!modules: Dls Spils}
{!modules: Nvector Nvector_serial Nvector_parallel Nvector_custom Nvector_array}
{!modules: Cvode Cvode_bbd Cvodes Cvodes_bbd}
{!modules: Ida Ida_bbd Idas Idas_bbd}
{!modules: Kinsol Kinsol_bbd}

{2:build Building the interface}

TODO: instructions for configuring and building the SundialsML interface.

{2:compilation Compiling programs}

TODO: Programs can be compiled using the
[-I +sundials] option and including [unix.cma] (or [.cmxa]),
[bigarray.cma] (or [.cmxa]) and [sundials_ida.cma] (or [.cmxa]), for example:
{[ocamlc -o myprogram -I +sundials unix.cma bigarray.cma sundials_ida.cma myprogram.ml]}
or:
{[ocamlopt -o myprogram -I +sundials unix.cmxa bigarray.cmxa sundials_ida.cmxa myprogram.ml]}

TODO: compiling with and without sensitivity.
TODO: compiling with and without mpi.

{2:performance Performance}

TODO: summarise performance; always slower since we add an interface layer,
but we exploit Bigarrays to minimise copying, OCaml is a memory managed
language (garbage collection, bounds checking, etc.. But, the interface does
not compare too badly:

TODO: include graph, explain methodology

TODO: performance tips for programs: a) type annotations for vectors; b)
avoid slice and sub; c) unwrap and use array access for matrices.

TODO: Thanks to OCaml's optimizations for (unboxed) floats and tight loops,
and also to the MPI and Bigarray libraries.

TODO: profile with -O3 and CHECK_MATRIX_ACCESS, etc. = 0.

{2:refs References}

- A. C. Hindmarsh, P. N. Brown, K. E. Grant, S. L. Lee, R. Serban, D. E.
Shumaker, and C. S. Woodward, "{b SUNDIALS: Suite of Nonlinear and
Differential/Algebraic Equation Solvers}," ACM Transactions on Mathematical
Software, 31(3), pp. 363-396, 2005.

{2:acks Acknowledgements}

TODO: acknowledge {{:https://itea3.org/project/modrio.html}Modrio} for (partial) funding.

TODO: Bigarray and mpi libraries.
TODO: Jonathan Protzenko's {{:http://www.xulforum.org/files/ocamlcss/style.css}CSS stylesheet} for OCamldoc
TODO: {{:http://www.mathjax.org}MathJax} for mathematics rendering.

{2:indexes Indexes}

{!indexlist}
{div close}
