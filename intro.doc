{div open id="intro"}

{{:https://computation.llnl.gov/casc/sundials/main.html}Sundials} is a
collection of five numerical solvers: CVODE,  CVODES, IDA, IDAS, and KINSOL.
It is written by Alan Hindmarsh, Radu Serban, and Carol Woodward at the {e
Center for Applied Scientific Computing, Lawrence Livermore National
Laboratory} with the contributions from Peter Brown, Scott Cohen, Aaron
Collier, Keith Grant, Steven Lee, Dan Reynolds, Dan Shumaker, and Allan
Taylor.

This OCaml interface was written by {{:http://www.tbrk.org}Timothy Bourke}
({{:http://www.inria.fr}Inria}/{{:http://www.di.ens.fr/}ENS}),
{{:http://www.owlnet.rice.edu/~ji2/}Jun Inoue}
({{:http://www.inria.fr}Inria}/{{:http://www.di.ens.fr/}ENS}),
and
{{:http://www.di.ens.fr/~pouzet/}Marc Pouzet}
({{:http://www.upmc.fr/}UPMC}/{{:http://www.inria.fr/}Inria}/{{:http://www.di.ens.fr/}ENS}).
It provides a complete OCaml interface to Sundials version {b {var version}}.

The structure of this interface mostly follows that of the original library,
both for ease of reading the existing documentation and for converting
existing source code, but several changes have been made for programming
convenience and preventing misuse, namely:
- solver sessions are mostly configured via algebraic data types
  rather than multiple function calls;
- error conditions are signalled by exceptions not return codes
  (including in user-supplied callback routines);
- closures (partial applications of functions) are used to
  share user data between callback routines, and;
- explicit free commands are not necessary since OCaml is a garbage-collected
  language.

Functions have been renamed according to a regular scheme. Leading {e
module identifier} are replaced by module paths, words
beginning with an uppercase letter are separated by underscores, and put
into lowercase. For instance, [IdaSetErrHandlerFn], becomes
{!Ida.set_err_handler_fn}, and [CVSpilsSetJacTimesVecFn] becomes
{!Cvode.Spils.set_jac_times_vec_fn}.

Constants are converted to variant types and exceptions, generally
named after {i CamlCase} conversions of their names in C.  However,
for exception names, we have taken the liberty to regularize them and
make them more descriptive.  For example, Sundials 2.5.0 declares
[CV_FIRST_RHSFUNC_ERR] and [IDA_FIRST_RES_FAIL], with inconsistencies
in "FUNC" and "ERR" / "FAIL".  In this binding, these error codes are
translated to the exceptions {!Cvode.FirstRhsFuncFailure} and
{!Ida.FirstResFuncFailure}, respectively.  For another example,
[CV_BAD_IS] is translated to {!Cvodes.Sensitivity.BadSensIdentifier}.

Rather than try to duplicate or replace the comprehensive
{{:https://computation.llnl.gov/casc/sundials/documentation/documentation.html}
Sundials user manuals}, this documentation provides brief summaries, taken
directly or adapted from the manual, with hyperlinks back to the original
text.

{2:nvector Nvectors}

Sundials defines an abstract interface for vectors and provides default
serial and parallel instantiations.
The OCaml interface defines likewise a generic
{!Sundials.nvector} type whose type arguments indicate the underlying {e
data} and {e kind}—one of {!Nvector_serial.kind}, {!Nvector_parallel.kind},
or {!Nvector_custom.kind}.
The {!Sundials.unvec} function gives direct access to the underlying data.

The interface to serial nvectors, {!Nvector_serial}, is based on
{{:http://caml.inria.fr/pub/docs/manual-ocaml/libref/Bigarray.html}Bigarrays}.
These arrays are manipulated directly, i.e., with no additional overhead,
within the solver by the original low-level serial nvector operations
(see {!Nvector.NVECTOR_OPS}).
The same low-level operations can be called from OCaml
({!Nvector_serial.Ops}), as can equivalent reimplementations on the
underlying data ({!Nvector_serial.DataOps}).

The interface to parallel nvectors, {!Nvector_parallel}, is also based on
{{:http://caml.inria.fr/pub/docs/manual-ocaml/libref/Bigarray.html}Bigarrays}.
It exploits the {{:https://forge.ocamlcore.org/projects/ocamlmpi/}OCaml/MPI}
library. Parallel nvectors are only available when Sundials/ML is configured
to use MPI, as described {{:install}below}.

Besides these two standard implementations, it is also possible to define
new nvector implementations through {!Nvector_custom} by providing low-level
operations on an underlying datatype. A demonstration of this feature on
{!float array}s is provided in {!Nvector_array}. Custom nvectors suffer two
disadvantages compared to the standard nvector implementations. First, each
low-level operation incurs the cost of a callback into OCaml. Second, of all
the provided linear solvers, only {!Cvode.Diag} could be used; although
custom solvers could be implemented through {!Cvode.Alternate},
{!Ida.Alternate}, and {!Kinsol.Alternate}.

{2:linsolv Linear Solvers}

TODO: write this

{2:modules Modules}

{!modules: Sundials}
{!modules: Dls Spils}
{!modules: Nvector Nvector_serial Nvector_parallel Nvector_custom Nvector_array}
{!modules: Cvode Cvode_bbd Cvodes Cvodes_bbd}
{!modules: Ida Ida_bbd Idas Idas_bbd}
{!modules: Kinsol Kinsol_bbd}

{2:install Dependencies and Installation}

The dependencies of Sundials/ML are
- {{:http://caml.inria.fr/ocaml/}OCaml} {b 3.12.1 or greater},
- {{:http://computation.llnl.gov/casc/sundials/}Sundials} {b {var version}},
- {e Optionally}:
  {{:https://forge.ocamlcore.org/projects/ocamlmpi/}OCaml/MPI} {b 1.01}.

The [configure] script detects whether Sundials was built with lapack
support, which is required for the [lapack_dense] and [lapack_band]
solvers (like {!Cvode.Dls.lapack_dense}).
The {!Sundials.blas_lapack_supported} value indicates whether these
solvers are available.

Parallel nvectors and Band-Block-Diagonal (BBD) solvers are {e
only} built if explicitly requested (via [--enable-mpi]).

{3:opam Opam}

Opam is the easiest way to install the library.

TODO: write instructions, how to get the different features, etc.

{3:build From source}

Building from source is a two step process:
{ol
    {- run [configure] to find and check dependencies, and}
    {- run [make install] to build and install the library.}
}

The choices made by the configure script can be influenced by arguments
(like [--enable-mpi] and [--prefix=...]) and variables (like
[OCAMLROOT=...]). Type [configure --help] for detailed information.

OCaml reimplementations of the standard Sundials examples are provided in
the [examples/] subdirectory.
The library's behaviour can be tested via [make tests.opt.log] which runs the OCaml
versions and compares their outputs against those of the original C
versions.
The library's performance can be analyzed via [make perf.opt.log] which
produces the graph explained {{:#performance}below}.

{2:compilation Compiling programs}

TODO: Programs can be compiled using the
[-I +sundials] option and including [unix.cma] (or [.cmxa]),
[bigarray.cma] (or [.cmxa]) and [sundials_ida.cma] (or [.cmxa]), for example:
{[ocamlc -o myprogram -I +sundials unix.cma bigarray.cma sundials_ida.cma myprogram.ml]}
or:
{[ocamlopt -o myprogram -I +sundials unix.cmxa bigarray.cmxa sundials_ida.cmxa myprogram.ml]}

TODO: compiling with and without sensitivity.
TODO: compiling with and without mpi.

{2:performance Performance}

An interface like Sundials/ML inevitably adds execution overhead: there is
extra code to execute at each call. But, how significant is this cost? And,
more broadly, how does the performance of OCaml compare to that of C for
programs that use numerical solvers?

These questions are not easy to answer. As a first attempt, the bars in
the following graph show the ratios of the execution times of the Sundials
examples reimplemented in OCaml to the original versions in C, i.e., a
value of 2 (on the axis at left) means an OCaml version that is
twice as slow.

{img perf.opt.png}

The graph suggests that the OCaml versions are rarely more than twice as
slow as the original ones and that they are often around or less than 50%
slower.
The [*_custom] example ({color #a1d99b light green}) uses custom nvectors
with low-level operations in OCaml and the [*_alt] examples ({color #31a354
dark green}) use linear solvers implemented in OCaml.

Such a conclusion seems reasonable as a first approximation, but several
details of the analysis process and individual results show that the real
situation is less clear-cut. For one, the running times of most of the
examples are so short that accurate profiling is not possible (i.e.,
{{:http://pubs.opengroup.org/onlinepubs/9699919799/utilities/time.html}time}
and {{:https://sourceware.org/binutils/docs/gprof/}gprof} simply show 0
seconds).
The figures in the graph were obtained by modifying the examples to
repeatedly execute their [main] functions.
The number of repetitions varies per example since otherwise the slower
examples take too long.
The timings indicated by the crosses and the axis at right are calculated by
dividing the measurement made for each C version by the number of repetitions.
All but six of the serial examples ({color #de2d26 red}) run so fast that 
comparisons are made based on tens, or usually hundreds of repetitions and
in some cases this amplifies factors other than the interface overhead.
For instance, some OCaml version spend a greater fraction of their time in
[printf], and we were able to lower their ratios by instead using
[print_string] and [print_int].

The parallel examples ({color #fc9272 lighter red}) all have relatively long
run times and results are obtained without iterating.
Their OCaml/C ratios are almost all close to 1—the interface and other
overheads are small compared to the dominating costs of parallelism and
communication.

We were able to make our OCaml versions much faster (up to 4 times) by
{ul
    {- Adding explicit type annotations to all vector arguments.
       For instance, rather than declare a callback with
       {[ let f t y yd = ... ,]}
       it is better to use
       {[ let f t (y : Sundials.RealArray.t) (yd : Sundials.RealArray.t) = ... ,]}
       since the OCaml compiler can then optimize according to the array
       layout.}
    {- Avoid functions like
       {{:http://caml.inria.fr/pub/docs/manual-ocaml/libref/Bigarray.Array1.html#VALsub}[Bigarray.Array1.sub]}
       and
       {{:http://caml.inria.fr/pub/docs/manual-ocaml/libref/Bigarray.Array2.html#VALslice_left}[Bigarray.Array2.slice_left]}
       whenever possible.
       These functions must allocate a new bigarray (using [malloc]) which
       can often be avoided by calculating and passing indices more
       explicitly.
       When part of an array must be passed to another function, it can be
       faster, depending on the size, to copy into and out of a
       statically-allocated temporary array.}
    {- Rather than a sequence of {!Sundials.RealArray2.get} and
       {!Sundials.RealArray2.set} operations, it is usually better to use
       {!Sundials.RealArray2.unwrap}, and then to access the underlying array
       directly.}
    {- Write numerical expressions and loops according to the advice in
	{{:#refs}\[2\]}
       to avoid float ‘boxing’.}
}

In summary, OCaml code using the Sundials solvers is usually not more than
50% slower than equivalent code written in C, provided some straightforward
guidelines are followed. It may, however, be faster to write and debug the
OCaml code thanks to automatic memory management, bounds checking on arrays,
strong static type checking, higher-order functions, etcetera. The
Sundials/ML library may be an optimal choice for code that combines symbolic
manipulations and numerical calculations.

{2:refs References}

{div open class="references"}
{ol
  {- A. C. Hindmarsh, P. N. Brown, K. E. Grant, S. L. Lee, R. Serban,
     D. E. Shumaker, and C. S. Woodward,
     “{{:http://computation.llnl.gov/casc/nsde/pubs/toms_sundials.pdf}{b
      SUNDIALS: Suite of Nonlinear and Differential/Algebraic Equation
      Solvers}},” ACM Transactions on Mathematical Software, 31(3),
      pp. 363-396, 2005.}
  {- X. Leroy,
     “{{:http://caml.inria.fr/pub/old_caml_site/ocaml/numerical.html}{b Old
      Objective Caml site: Writing efficient numerical code in Objective
      Caml}},” July 2002.}
}
{div close}

{2:acks Acknowledgements}

We gratefully acknowledge the support of the
{{:https://itea3.org/project/modrio.html} ITEA 3 project 11004 MODRIO} (Model
driven physical systems operation), {{:http://www.inria.fr/}Inria}, and
the {{:http://www.di.ens.fr/}Departement d'Informatique de l'ENS}.

This library benefits greatly from the OCaml {{:http://caml.inria.fr/pub/docs/manual-ocaml/libref/Bigarray.html}Bigarray} and {{:https://forge.ocamlcore.org/projects/ocamlmpi/}MPI}
libraries, and from {{:https://ocaml.org/}OCaml}'s optimised floating-point
representations and compilation.

This documentation uses J. Protzenko's
{{:http://www.xulforum.org/files/ocamlcss/style.css}CSS stylesheet}, and
{{:http://www.mathjax.org}MathJax} for rendering mathematics.

{2:indexes Indexes}

{!indexlist}
{div close}

