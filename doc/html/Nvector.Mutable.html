<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="next" href="Nvector.Immutable.html">
<link rel="Up" href="Nvector.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Sundials" rel="Chapter" href="Sundials.html">
<link title="Nvector" rel="Chapter" href="Nvector.html">
<link title="Nvector_array" rel="Chapter" href="Nvector_array.html">
<link title="Cvode" rel="Chapter" href="Cvode.html">
<link title="Cvode_nvector" rel="Chapter" href="Cvode_nvector.html">
<link title="Cvode_serial" rel="Chapter" href="Cvode_serial.html"><title>Sundials (-CVODE) : Nvector.Mutable</title>
</head>
<body>
<div class="navbar">&nbsp;<a href="Nvector.html">Up</a>
&nbsp;<a href="Nvector.Immutable.html">Next</a>
</div>
<center><h1>Module <a href="type_Nvector.Mutable.html">Nvector.Mutable</a></h1></center>
<br>
<pre><span class="keyword">module</span> Mutable: <code class="code">sig</code> <a href="Nvector.Mutable.html">..</a> <code class="code">end</code></pre>Generic nvectors defined through sets of imperative operations on
    mutable data types.<br>
<hr width="100%">
<br><code><span id="TYPEnvector_ops"><span class="keyword">type</span> <code class="type">'a</code> nvector_ops</span> = {</code><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>nvclone&nbsp;: <code class="type">'a -> 'a</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >Creates a new nvector of the same type as an existing vector.
          It need not copy the existing vector, but rather just allocate
          storage for the new vector.</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>nvdestroy&nbsp;: <code class="type">('a -> unit) option</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >Destroys the N_Vector v and frees memory allocated for its internal
          data.</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>nvspace&nbsp;: <code class="type">('a -> int * int) option</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" >Returns storage requirements for one nvector. In the pair <code class="code">(lrw,
          liw)</code>, <code class="code">lrw</code> is the number of realtype words required, and <code class="code">liw</code> is
          the number of integer words required.</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>nvlinearsum&nbsp;: <code class="type">float -> 'a -> float -> 'a -> 'a -> unit</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code class="code">nvlinearsum a x b y z</code> performs the operation
          <code class="code">z</code> = <code class="code">a</code>*<code class="code">x</code> + <code class="code">b</code>*<code class="code">y</code>, where <code class="code">a</code> and <code class="code">b</code> are scalars and
          <code class="code">x</code> and <code class="code">y</code> are vectors:
          <code class="code">z</code>(<i>i</i>) = <code class="code">a</code>*<code class="code">x</code>(<i>i</i>) + <code class="code">b</code>*<code class="code">y</code>(<i>i</i>).</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>nvconst&nbsp;: <code class="type">float -> 'a -> unit</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code class="code">nvconst c z</code> sets all components of <code class="code">z</code> to <code class="code">c</code>: <code class="code">z</code>(<i>i</i>) = c.</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>nvprod&nbsp;: <code class="type">'a -> 'a -> 'a -> unit</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code class="code">nvprod x y z</code> sets <code class="code">z</code> to be the component-wise product of <code class="code">x</code>
          and <code class="code">y</code>: <code class="code">z</code>(<i>i</i>) = x(<i>i</i>) * y(<i>i</i>).</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>nvdiv&nbsp;: <code class="type">'a -> 'a -> 'a -> unit</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code class="code">nvdiv x y z</code> sets <code class="code">z</code> to be the component-wise ratio of <code class="code">x</code> and
          <code class="code">y</code>: <code class="code">z</code>(<i>i</i>) = <code class="code">x</code>(<i>i</i>) / <code class="code">y</code>(<i>i</i>).
          This function should only be called with a <code class="code">y</code> whose components
          are all guaranteed to be nonzero.</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>nvscale&nbsp;: <code class="type">float -> 'a -> 'a -> unit</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code class="code">nvscale c x z</code> scales <code class="code">x</code> by <code class="code">c</code> and returns the result in <code class="code">z</code>:
          <code class="code">z</code>(<i>i</i>) = <code class="code">c</code> * <code class="code">x</code>(<i>i</i>).</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>nvabs&nbsp;: <code class="type">'a -> 'a -> unit</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code class="code">nvabs x z</code> sets the components of <code class="code">z</code> to the absolute values of
          the components of <code class="code">x</code>: <code class="code">z</code>(<i>i</i>) = |<code class="code">x</code>(<i>i</i>)|.</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>nvinv&nbsp;: <code class="type">'a -> 'a -> unit</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code class="code">nvinv x z</code> sets the components of <code class="code">z</code> to be the inverses of the
         components of <code class="code">x</code>: <code class="code">z</code>(<i>i</i>) = 1.0 / <code class="code">x</code>(<i>i</i>).
         This function should only be called with an <code class="code">x</code> whose
         components are all guaranteed to be nonzero.</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>nvaddconst&nbsp;: <code class="type">'a -> float -> 'a -> unit</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code class="code">nvaddconst x b z</code> adds <code class="code">b</code> to all components of <code class="code">x</code> and
          returns the result in <code class="code">z</code>: <code class="code">z</code>(<i>i</i>) = <code class="code">x</code>(<i>i</i>) + <code class="code">b</code>.</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>nvmaxnorm&nbsp;: <code class="type">'a -> float</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code class="code">m = nvmaxnorm x</code> returns the maximum norm of <code class="code">x</code>:
          <code class="code">m</code> = |<code class="code">x</code>(<i>i</i>)|.</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>nvwrmsnorm&nbsp;: <code class="type">'a -> 'a -> float</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code class="code">m = nvwrmsnorm x w</code> returns the weighted root-mean-square norm of
          <code class="code">x</code> with weight vector <code class="code">w</code>:
            <code class="code">m</code> = sqroot( sum( sqr(<code class="code">x</code>(<i>i</i>) * w(<i>i</i>)) ) / n ).</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>nvmin&nbsp;: <code class="type">'a -> float</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code class="code">m = nvmin(x)</code> returns the smallest element of <code class="code">x</code>,
          <code class="code">m</code> = min(<code class="code">x</code>(<i>i</i>)).</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>nvdotprod&nbsp;: <code class="type">('a -> 'a -> float) option</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code class="code">d = nvdotprod x y</code> returns the ordinary dot product of <code class="code">x</code> and <code class="code">y</code>,
          <code class="code">d</code> = sum(<code class="code">x</code>(<i>i</i>) * <code class="code">y</code>(<i>i</i>)).</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>nvcompare&nbsp;: <code class="type">(float -> 'a -> 'a -> unit) option</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code class="code">nvcompare c x z</code> compares the components of <code class="code">x</code> to the scalar <code class="code">c</code>
          and returns <code class="code">z</code> such that <code class="code">z</code>(<i>i</i>) = 1.0 if |<code class="code">x</code>(<i>i</i>)| &gt;= <code class="code">c</code>
          and <code class="code">z</code>(<i>i</i>) = 0.0 otherwise.</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>nvinvtest&nbsp;: <code class="type">('a -> 'a -> bool) option</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code class="code">t = nvinvtest x z</code> sets the components of <code class="code">z</code> to be the inverses of
          the components of <code class="code">x</code>, with prior testing for zero values:
            <code class="code">z</code>(<i>i</i>) = 1.0 / <code class="code">x</code>(<i>i</i>).
          This routine returns <code class="code">true</code> if all components of <code class="code">x</code> are nonzero
          (successful inversion) and <code class="code">false</code> otherwise.</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>nvwl2norm&nbsp;: <code class="type">('a -> 'a -> float) option</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code class="code">m = nvwl2norm x w</code> returns the weighted Euclidean l_2 norm of <code class="code">x</code>
          with weight vector <code class="code">w</code>
          <code class="code">m</code> = sqroot( sum( sqr(<code class="code">x</code>(<i>i</i>) * w(<i>i</i>)) ) ).</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>nvl1norm&nbsp;: <code class="type">('a -> float) option</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code class="code">m = nvl1norm x</code> returns the l_1 norm of <code class="code">x</code>:
          <code class="code">m</code> = sum(|x(<i>i</i>)|)</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>nvwrmsnormmask&nbsp;: <code class="type">('a -> 'a -> 'a -> float) option</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code class="code">m = nvwrmsnormmask x w id</code> returns the weighted root mean square
          norm of <code class="code">x</code> with weight vector <code class="code">w</code> built using only the elements
          of <code class="code">x</code> corresponding to nonzero elements of <code class="code">id</code>:
            <code class="code">m</code> = sqroot( sum( sqr(<code class="code">x</code>(<i>i</i>) * w(<i>i</i>)
            * sign(id(<i>i</i>))) ) / n ).</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>nvconstrmask&nbsp;: <code class="type">('a -> 'a -> 'a -> bool) option</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code class="code">t = nvconstrmask c x m</code> performs the following constraint tests:<ul>
<li><code class="code">x</code>(<i>i</i>) &gt; 0 if <code class="code">c</code>(<i>i</i>)  = 2,</li>
<li><code class="code">x</code>(<i>i</i>) &gt;= 0 if <code class="code">c</code>(<i>i</i>) = 1,</li>
<li><code class="code">x</code>(<i>i</i>) &lt;= 0 if <code class="code">c</code>(<i>i</i>) = -1,</li>
<li><code class="code">x</code>(<i>i</i>) &lt; 0 if <code class="code">c</code>(<i>i</i>)  = -2.</li>
</ul>

          There is no constraint on <code class="code">x</code>(<i>i</i>) if <code class="code">c</code>(<i>i</i>) = 0.
          This routine returns <code class="code">false</code> if any element failed the constraint
          test, and <code class="code">true</code> if all passed. It also sets a mask vector <code class="code">m</code>,
          with elements equal to 1.0 where the constraint test failed,
          and 0.0 where the test passed. This routine is used only for
          constraint checking.</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code>nvminquotient&nbsp;: <code class="type">('a -> 'a -> float) option</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><code class="code">minq = nvminquotient num denom</code> returns the minimum of the
          quotients obtained by term-wise dividing <code class="code">num</code>(<i>i</i>) by
          <code class="code">denom</code>(<i>i</i>). A zero element in <code class="code">denom</code> will be skipped.
          If no such quotients are found, then <a href="Sundials.html#VALbig_real"><code class="code">Sundials.big_real</code></a>
          is returned.</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}

<div class="info">
The set of operations required to define an <a href="Nvector.html#TYPEnvector"><code class="code">Nvector.nvector</code></a>. Some operations
       are optional; default values are either provided by the Ocaml interface
       or the Sundials library.<br>
<div class="cvode"><small>
              See sundials: <a href="https://computation.llnl.gov/casc/sundials/documentation/cv_guide/node7.html#s:nvector">_generic_N_Vector_Ops</a>
            </small></div></div>

<pre><span id="VALmake_nvector"><span class="keyword">val</span> make_nvector</span> : <code class="type">'a <a href="Nvector.Mutable.html#TYPEnvector_ops">nvector_ops</a> -> 'a -> 'a <a href="Nvector.html#TYPEnvector">Nvector.nvector</a></code></pre><div class="info">
<code class="code">make_nvector ops</code> takes a set of operations on the data
        type <code class="code">'a</code> and yields a function for lifting values of type <code class="code">'a</code>
        into <code class="code">'a</code> <a href="Nvector.html#TYPEnvector"><code class="code">Nvector.nvector</code></a>s which can be passed to a solver (like
        <a href="Cvode_nvector.html"><code class="code">Cvode_nvector</code></a>).<br>
</div>
<pre><span id="VALnvector_data"><span class="keyword">val</span> nvector_data</span> : <code class="type">'a <a href="Nvector.html#TYPEnvector">Nvector.nvector</a> -> 'a</code></pre><div class="info">
Extracts the data from an <a href="Nvector.html#TYPEnvector"><code class="code">Nvector.nvector</code></a>.<br>
</div>
<pre><span id="VALadd_tracing"><span class="keyword">val</span> add_tracing</span> : <code class="type">string -> 'a <a href="Nvector.Mutable.html#TYPEnvector_ops">nvector_ops</a> -> 'a <a href="Nvector.Mutable.html#TYPEnvector_ops">nvector_ops</a></code></pre><div class="info">
<code class="code">add_tracing p ops</code> modifies a set of <a href="Nvector.Mutable.html#TYPEnvector_ops"><code class="code">Nvector.Mutable.nvector_ops</code></a> so that
        a message, prefixed by <code class="code">p</code>, is printed each time an operation
        is called. This function is intended to help debug sets of
        vector operations.<br>
</div>
</body></html>