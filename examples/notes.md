Benchmarking notes
==================

* Ensure that Sundials is built with `-DCMAKE_BUILD_TYPE=Release`, otherwise 
  it is compiled without any optimisations.

* Official benchmarks should be built with 
    make perf.opt.log GC_AT_END=1 PERF_DATA_POINTS=10

  The ‘unsafe’ data (i.e., no array bounds checks, etc.) is generated by 
  rebuilding Sundials/ML with `--unsafe`.

Analysis/Debugging
==================

Performance differences can be analyzed with 
[valgrind](http://valgrind.org), 
[kcachegrind](https://kcachegrind.github.io), or Linux's `perf stat`.

To run everything with valgrind:
    make RUN_WITH_VALGRIND=1 tests.opt.log

Or just a single example:
    GC_EACH_REP=1 GC_AT_END=1 valgrind --leak-check=full \
      ./ark_heat1D_adapt.opt > /dev/null

To run a program under valgrind so that gdb can attach to it:
    GC_AT_END=1 valgrind --leak-check=full --vgdb=full \
      --vgdb-error=0 ./ark_heat1D_adapt.opt > /dev/null

Triggering leak checks from gdb + valgrind:
    # Assume gdb is attached to a process supervised by valgrind.
    monitor leak_check full reachable any  # Check leaks.
    monitor block_list <loss record ID(s)> # Get details of the leak.

The examples can be compiled to use the OCaml runtime with debugging 
features (like assertions) enabled.
    make COMPILE_WITH_RUNTIME_DEBUG=1

