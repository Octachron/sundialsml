module Ida = Ida_serial
module Carray = Ida_serial.Carray
module Roots = Ida.Roots
open Quickcheck
open IdaModel
open Camlp4.PreCast
open Pprint
open Pprint_sundials

(* A state-machine model for IDA sessions.  *)
type session_model =
  {
    resfn : resfn_type;
    mutable solver : Ida.linear_solver;
    mutable solving : bool;
    mutable consistent : bool;
    mutable t : float;
    mutable roots : (float * Ida.Roots.root_event) array;
    mutable root_info : Roots.t;
    vec : Carray.t;
    vec' : Carray.t;
    t0 : float;
    vec0 : Carray.t;
    vec'0 : Carray.t;
  }
type script = session_model * cmd list

let copy_resfn = function
  | ResFnLinear slopes -> ResFnLinear (Carray.of_carray slopes)
let copy_model m =
  {
    resfn = copy_resfn m.resfn;
    solver = m.solver;
    solving = m.solving;
    t = m.t;
    roots = Array.copy m.roots;
    root_info = Roots.copy m.root_info;
    consistent = m.consistent;
    vec = Carray.of_carray m.vec;
    vec' = Carray.of_carray m.vec';
    t0 = m.t0;
    vec0 = Carray.of_carray m.vec0;
    vec'0 = Carray.of_carray m.vec'0;
  }

let pp_model, dump_model, show_model, display_model,
    print_model, prerr_model
      =
  printers_of_pp
    (let descriptive_fields =
       ["resfn", (fun fmt m -> pp_of_show show_resfn_type fmt m.resfn);
        "solver", (fun fmt m -> pp_of_show show_solver fmt m.solver);
        "roots", (fun fmt m -> pp_array (pp_pair pp_float pp_root_event)
          fmt m.roots);
        "t", (fun fmt m -> pp_float fmt m.t);
        "vec", (fun fmt m -> pp_carray fmt m.vec);
        "vec'", (fun fmt m -> pp_carray fmt m.vec');
        "t0", (fun fmt m -> pp_float fmt m.t0);
        "vec0", (fun fmt m -> pp_carray fmt m.vec0);
        "vec'0", (fun fmt m -> pp_carray fmt m.vec'0);
       ]
     and state_fields =
       ["root_info", (fun fmt m -> pp_root_info fmt m.root_info);
        "solving", (fun fmt m -> pp_bool fmt m.solving);
        "consistent", (fun fmt m -> pp_bool fmt m.consistent);
       ]
     in
     let rw_invar = pp_record (descriptive_fields @ state_fields)
     and concise = pp_record descriptive_fields in
     fun fmt m ->
       if !read_write_invariance then rw_invar fmt m
       else concise fmt m)

let pp_script, dump_script, show_script, display_script,
    print_script, prerr_script
      =
  printers_of_pp (fun fmt (model, cmds) ->
    Format.fprintf fmt "@[<hov 2>let model =@ ";
    pp_model fmt model;
    Format.fprintf fmt "@]@\n@[<hov 2>let cmds =@ ";
    pp_cmds fmt cmds;
    Format.fprintf fmt "@]@\n@[<hov 2>let script =@ (model, cmds)@]"
  )

(* Find the smallest root(s) in the range (t1..t2].  *)
let find_roots roots t1 t2 =
  let n = Array.length roots in
  let pos i = fst roots.(i) in
  if n = 0 then []
  else
    let record  = ref t2
    and holders = ref []
    in
    for i = 0 to n-1 do
      if t1 < pos i && pos i <= !record
      then
        begin
          if pos i < !record then
            (record := pos i;
             holders := [i])
          else
            holders := i::!holders
        end
    done;
    !holders

(* The test code is generated by Camlp4 and compiled and run in a separate
   process.  This is done for two reasons:

    - In the worst case, IDA segfaults and this is hard to catch cleanly in
      OCaml.  Running it in a separate process saves the main driver loop from
      crashing together with the test case, so that it can shrink and re-run
      the test case.

    - Once we find a bug, we have to present a test case to the user, and a
      self-contained .ml file is the best way to do it.  So we need code
      generation anyway.  *)

let _loc = Loc.ghost

let semis when_empty ctor = function
  | [] -> when_empty
  | e::es -> ctor (List.fold_left (fun e1 e2 -> Ast.ExSem (_loc, e1, e2)) e es)
let expr_array es = semis <:expr<[||]>> (fun e -> Ast.ExArr (_loc, e)) es
let expr_seq es = semis <:expr<()>> (fun e -> Ast.ExSeq (_loc, e)) es
let expr_of_carray v =
  let n = Carray.length v in
  if n = 0 then <:expr<Carray.create 0>>
  else <:expr<Carray.of_array
              $expr_array (List.map (fun i -> <:expr<$`flo:v.{i}$>>)
                            (enum 0 (n-1)))$>>
let expr_of_linear_solver = function
  | Ida.Dense -> <:expr<Ida.Dense>>
  | Ida.Band range -> <:expr<Ida.Band
                             { Ida.mupper = $`int:range.Ida.mupper$;
                               Ida.mlower = $`int:range.Ida.mlower$; }>>
  | Ida.Sptfqmr _ | Ida.Spbcg _ | Ida.Spgmr _
  | Ida.LapackBand _ | Ida.LapackDense _ ->
    raise (Failure "linear solver not implemented")

let expr_of_resfn neqs = function
  | ResFnLinear slopes ->
    (* forall i. vec.{i} = slopes.{i}*t *)
    let set i = <:expr<res.{$`int:i$}
                         <- vec'.{$`int:i$} -. $`flo:slopes.{i}$>>
    in <:expr<fun t vec vec' res ->
               $expr_seq (List.map set (enum 0 (neqs-1)))$>>
let exact_soln typ t0 vec0 vec'0 t vec vec' =
  match typ with
  | ResFnLinear slopes ->
    for i = 0 to Carray.length vec - 1 do
      vec'.{i} <- slopes.{i};
      vec.{i} <- slopes.{i} *. (t -. t0);
    done
let exact_init model =
  match model.resfn with
  | ResFnLinear slopes ->
    Carray.fill model.vec 0.;
    Carray.fill model.vec0 0.;
    model.consistent <- true

let expr_of_roots roots =
  let n = Array.length roots in
  let set i =
    match roots.(i) with
    | r, Roots.Rising -> <:expr<g.{$`int:i$} <- t -. $`flo:r$>>
    | r, Roots.Falling -> <:expr<g.{$`int:i$} <- $`flo:r$ -. t>>
    | _, Roots.NoRoot -> assert false
  in
  let f ss i = <:expr<$ss$; $set i$>> in
  if n = 0 then <:expr<Ida.no_roots>>
  else <:expr<($`int:n$,
               (fun t vec vec' g ->
                  $Fstream.fold_left f (set 0)
                    (Fstream.enum 1 (n-1))$))>>

(* Generate the test code that executes a given command.  *)
let expr_of_cmd last_query_time = function
  | SolveNormal dt ->
    let t = !last_query_time +. dt in
    last_query_time := t;
    <:expr<let tret, flag = Ida.solve_normal session $`flo:t$ vec vec' in
           Aggr [Float tret; SolverResult flag; carray vec; carray vec']>>
  | GetRootInfo ->
    <:expr<let roots = Ida.Roots.create (Ida.nroots session) in
           Ida.get_root_info session roots;
           RootInfo roots>>
let expr_of_cmds last_query_time = function
  | [] -> <:expr<()>>
  | cmds ->
  <:expr<
    Array.iter print_result
    $expr_array (List.map (fun cmd ->
    <:expr<lazy $expr_of_cmd last_query_time cmd$>>) cmds)$
    >>

(* Run a single command on the model.  *)
let model_cmd model = function
  | SolveNormal dt ->
    (* NB: we don't model interpolation failures -- t will be monotonically
       increasing.  *)
    let t = model.t +. dt in
    (* Undocumented behavior (sundials 2.5.0): solve_normal with t=t0 usually
       fails with "tout too close to t0 to start integration", but sometimes
       succeeds.  Whether it succeeds seems to be unpredictable.  *)
    if t = model.t0 then Any
    else
      let tret, flag =
        (* NB: roots that the solver is already sitting on are ignored, unless
           dt = 0.  *)
        let tstart = if dt = 0. then model.t -. time_epsilon else model.t in
        match find_roots model.roots tstart t with
        | [] ->
          (*Roots.reset model.root_info;*)
          t, SolverResult Ida.Continue
        | (i::_) as is ->
          let tret = fst model.roots.(i) in
          Roots.reset model.root_info;
          List.iter
            (fun i -> Roots.set model.root_info i (snd model.roots.(i)))
            is;
          (tret,
           (* If the queried time coincides with a root, then it's reasonable
              for the solver to prioritize either.  In real code, this is most
              likely determined by the state of the floating point error.  *)
           if tret = t then Type (SolverResult Ida.Continue)
           else SolverResult Ida.RootsFound)
      in
      model.t <- t;
      model.solving <- true;
      exact_soln model.resfn model.t0 model.vec0 model.vec'0
                                 tret model.vec  model.vec';
      Aggr [Float tret; flag; carray model.vec; carray model.vec']
  | GetRootInfo ->
    if model.solving then RootInfo (Roots.copy model.root_info)
    else
      (* FIXME: this should be Exn Ida.IllInput or something like that.  *)
      Type (RootInfo (Roots.copy model.root_info))

(* Run a list of commands on the model.  *)
let model_run (model, cmds) =
  let model = copy_model model in
  (* Evaluation order requires this let here.  *)
  let head = Aggr [Float model.t;
                   carray model.vec;
                   carray model.vec']
  in head :: List.map (model_cmd model) cmds

let ml_code_of_script (model, cmds) =
  let last_query_time = ref model.t0 in
  <:str_item<
    module Ida = Ida_serial
    module Carray = Ida.Carray
    open Quickcheck.IdaModel
    open Pprint
    (* Remove error messages so that they don't have to be replicated with 100%
       accuracy in models.  *)
    let nub_exn = function
      | Failure _ -> Failure ""
      | Invalid_argument _ -> Invalid_argument ""
      | exn -> exn
    let marshal_results = ref false
    let print_result thunk =
      (if !marshal_results
       then (fun r -> Marshal.to_channel stdout r [])
       else (fun r -> Printf.printf "%s\\n" (show_result r)))
      (try (Lazy.force thunk)
       with exn -> Exn (nub_exn exn))
    let vec  = $expr_of_carray model.vec0$
    let vec' = $expr_of_carray model.vec'0$
    let session = Ida.init_at_time
                  $expr_of_linear_solver model.solver$
                  $expr_of_resfn (Carray.length model.vec0) model.resfn$
                  $expr_of_roots model.roots$
                  $`flo:model.t0$
                  vec vec'
    let test () =
      print_result (lazy (Aggr [Float (Ida.get_current_time session);
                                carray vec; carray vec']));
      $expr_of_cmds last_query_time cmds$
    let _ =
      Arg.parse
        [("--marshal-results", Arg.Set marshal_results,
          "For internal use only");
         ("--read-write-invariance", Arg.Set read_write_invariance,
          "print data in a format that can be fed to ocaml toplevel")]
        (fun _ -> ()) "a test case generated by quickcheck";
      test ()
   >>


(* Test case generation.  *)

let gen_vec neqs = Carray.of_array (gen_array ~size:neqs gen_discrete_float)

let gen_resfn neqs =
  gen_choice
    [|
      fun () -> let v = Carray.create neqs in
                for i = 0 to Carray.length v - 1 do
                  v.{i} <- float_of_int i
                done;
                ResFnLinear v
    |]
    ()

let gen_solver lapack neqs =
  match Random.int 1 with
  | 0 -> if lapack && Random.bool () then Ida.LapackDense else Ida.Dense
  | _ -> assert false

let init_vec_for neqs t0 resfn =
  match resfn with
  | ResFnLinear slopes -> Carray.init neqs 0., Carray.of_carray slopes

let gen_roots () =
  (* We have to ensure the roots don't coincide with any of the query times or
     with one another, for otherwise the order in which they fire is dictated
     by floating point error and is unpredictable.  *)
  let gen_root () =
    (gen_root_time (),
     gen_choice [| Roots.Rising; Roots.Falling |])
  in
  match Random.int 3 with
  | 0 -> [||]
  | _ -> uniq_array (gen_array gen_root)

let gen_model () =
  let neqs  = min 10 (gen_pos ()) in
  let resfn = gen_resfn neqs in
  let t0 = gen_discrete_float () in
  let vec0, vec'0  = init_vec_for neqs t0 resfn in
  let neqs  = Carray.length vec0 in
  let roots = gen_roots () in
  {
    resfn = resfn;
    solver = gen_solver false neqs;
    solving = false;
    t = t0;
    consistent = true;
    roots = roots;
    root_info = Roots.create (Array.length roots);
    vec   = Carray.of_carray vec0;
    vec'  = Carray.of_carray vec'0;
    t0 = t0;
    vec0  = vec0;
    vec'0 = vec'0;
  }

let gen_cmd =
  let cases =
    [| (fun () -> SolveNormal (abs_float (gen_discrete_float ())));
       (fun () -> GetRootInfo) |]
  in
  fun () -> gen_choice cases ()
let gen_cmds () = gen_list gen_cmd


(* Fix the generated script so that it's reasonably sane.  Right now, the
   fix-ups performed are:

 *)
let fixup_script (model, cmds) =
  (* We do a dry run of the model, calling a bunch of fix-up functions before
     executing each command.  The fix-up functions can use a model as a
     reference to determine if the command is legitimate or is in need of
     fixing.  *)
  let rec go fs processed model = function
    | cmd::cmds -> let cmd = List.fold_left (fun c f -> f model c) cmd fs in
                   ignore (model_cmd model cmd);
                   go fs (cmd::processed) model cmds
    | [] -> List.rev processed
  in
  (model, go [] [] (copy_model model) cmds)

let gen_script () =
  let model = gen_model ()
  and cmds  = gen_cmds ()
  in fixup_script (model, cmds)

(* Shrinking *)
let shrink_neqs model cmds =
  (* Reduce commands that are dependent on number of equations.  *)
  let drop_from_cmd i = function
    | cmd -> cmd
  in
  let copy_vec_drop i v =
    let n = Carray.length v in
    let w = Carray.create (n-1) in
    for j = 0 to i-1 do
      w.{j} <- v.{j}
    done;
    for j = i+1 to n - 1 do
      w.{j-1} <- v.{j}
    done;
    w
  in
  let copy_resfn_drop i = function
    | ResFnLinear slopes -> ResFnLinear (copy_vec_drop i slopes)
  in
  let drop_eq i =
    let model =
      {
        resfn = copy_resfn_drop i model.resfn;
        roots = Array.copy model.roots;
        root_info = Roots.copy model.root_info;
        solving = model.solving;
        consistent = model.consistent;
        vec = copy_vec_drop i model.vec;
        vec' = copy_vec_drop i model.vec';
        t0 = model.t0;
        vec0 = copy_vec_drop i model.vec0;
        vec'0 = copy_vec_drop i model.vec'0;
        solver = model.solver;
        t = model.t;
      }
    in (model, List.map (drop_from_cmd i) cmds)
  in
  let n = Carray.length model.vec in
  Fstream.guard (n > 1) (Fstream.map drop_eq (Fstream.enum 0 (n - 1)))

let shrink_root_dir = function
  | Roots.Rising -> Fstream.nil
  | Roots.Falling -> Fstream.singleton Roots.Rising
  | Roots.NoRoot -> assert false
let shrink_root_pos = shrink_offseted_discrete_float root_time_offs

let shrink_model model cmds =
  let update_roots model roots =
    let root_info = Roots.create (Array.length roots) in
    { model with roots = roots; root_info = root_info }
  in
  Fstream.map (fun t -> ({ model with t = t; t0 = t; }, cmds))
    (shrink_discrete_float model.t)
  @@ Fstream.map (fun roots -> (update_roots model roots, cmds))
    (shrink_array (shrink_pair shrink_root_pos shrink_root_dir)
       model.roots)

let shrink_cmd = function
  | SolveNormal dt ->
    Fstream.map (fun dt -> SolveNormal dt) (shrink_query_time dt)
  | GetRootInfo -> Fstream.nil

let shrink_script (model, cmds) =
  shrink_neqs model cmds
  @@ shrink_model model cmds
  @@ Fstream.map (fun cmds -> (model, cmds)) (shrink_list shrink_cmd cmds)

(* Code generation options *)
let test_exec_file = ref "./tmp"
let test_compiler =
  ref "ocamlc -g -I .. bigarray.cma unix.cma sundials_ida.cma \
       fstream.cmo pprint.cmo pprint_sundials.cmo quickcheck.cmo"
let test_failed_file = ref "./failed.ml"

(* Generate test code, run it, and return a stream of responses.  *)
let compile script =
  let open Camlp4.PreCast.Printers.OCaml in
  let test_src_file = !test_exec_file ^ ".ml" in
  print_implem ~output_file:test_src_file (ml_code_of_script script);
  let compile_command =
    !test_compiler ^ " -o " ^ !test_exec_file ^ " " ^ test_src_file
  in
  match Unix.system compile_command with
  | Unix.WEXITED 0 -> ()
  | Unix.WEXITED _ | Unix.WSIGNALED _ | Unix.WSTOPPED _ ->
    raise (Failure ("Internal error: generated code failed to compile.  \
                     Compilation command was: " ^ compile_command))

let compile_run script =
  compile script;
  let (pipe_stdout, pipe_stdin, pipe_stderr) as pipes =
    Unix.open_process_full
      (!test_exec_file ^ " --marshal-results")
      (Unix.environment ())
  in
  let recv () =
    try Some (Marshal.from_channel pipe_stdout : result)
    with End_of_file -> (ignore (Unix.close_process_full pipes); None)
  in
  Fstream.to_list (Fstream.generate recv)

(* Run the model and the actual code and check if their results agree.  *)
let compare_runs script =
  let ms0 = model_run script
  and cs0 = compile_run script in
  let rec cmp i ms cs =
    match ms, cs with
    | [], [] -> OK
    | m::ms, c::cs ->
      if result_matches m c then cmp (i+1) ms cs
      else Failed (ResultMismatch (i, m, c))
    | _::_, [] ->
      Failed (TestCodeDied ms)
    | [], _::_ ->
      Failed TestCodeOverrun
  in
  cmp 0 ms0 cs0

let trace_shrink = ref false
let dump_test_cases = ref false

let shrink script reason =
  if !trace_shrink then print_char '\n';
  let rec go ct script reason =
    let failure script =
      let res = compare_runs script in
      if !trace_shrink then
        (Printf.printf "Trying: %s\n-> %s\n"
           (show_script script)
           (if res <> OK then "triggers bug"
            else "not a counterexample");
         flush stdout);
      match res with
      | OK -> None
      | Failed reason -> Some (script, reason)
    in
    match Fstream.find_some failure (shrink_script script) with
    | None -> (ct, script, reason)
    | Some (script, reason) -> go (ct+1) script reason
  in go 0 script reason

let test_script script =
  if !dump_test_cases then
    (Printf.printf "Testing: %s\n" (show_script script); flush stdout);
  match compare_runs script with
  | OK -> true
  | Failed reason ->
    Printf.fprintf stderr "\nFailed!  Shrinking..."; flush stderr;
    let (ct, ((model, cmds) as script), reason) = (shrink script reason) in
    Printf.fprintf stderr
      " %d shrinks.\nFailed test code saved in %s.\n\n[Reason]\n"
      ct
      !test_failed_file;
    (* The test file contains the last script tried, not the last script that
       failed.  We need to update it.  *)
    compile script;
    (match reason with
       | TestCodeDied rs ->
         Printf.fprintf stderr "Test code exited unexpectedly.  It was \
                                supposed to produce the following additional \
                                results:\n";
         prerr_results rs
       | TestCodeOverrun -> assert false (* Shouldn't happen.  *)
       | ResultMismatch (i,e,a) ->
         Printf.fprintf stderr "Result mismatch on %s:\n\
                                expected\n%s\nbut got\n%s\n"
           (if i = 0 then "init" else ("step " ^ string_of_int i))
           (show_result e)
           (show_result a));
    Printf.fprintf stderr "\n[Test Case]\n";
    prerr_string (show_script script);
    Printf.fprintf stderr "\n\n[Program Output]\n";
    flush stderr;
    flush stdout;
    let pid = Unix.create_process !test_exec_file
      (if !read_write_invariance
       then [|!test_exec_file; "--read-write-invariance"|]
       else [|!test_exec_file|])
      Unix.stdin Unix.stdout Unix.stderr
    in
    let _ = Unix.waitpid [] pid in
    let infile  = open_in (!test_exec_file ^ ".ml")
    and outfile = open_out !test_failed_file in
    let _ =
      try while true do output_char outfile (input_char infile) done
      with End_of_file -> ()
    in
    Printf.fprintf stderr "\n\n[Expected Output]\n";
    prerr_results (model_run script);
    false

let quickcheck max_tests =
  let rec go = function
    | 0 -> Printf.printf "\n+++ OK, passed %d tests." max_tests; None
    | tests ->
      let script = gen_script () in
      if test_script script then
        (print_char '*';
         flush stdout;
         size := !size+1;
         go (tests-1))
      else Some script
  in go (max 0 max_tests)

;;
let _ =
  let _ = Random.self_init () in
  let randseed = ref (Random.int ((1 lsl 30) - 1)) in
  let max_tests = ref 50 in
  let options = [("--exec-file", Arg.Set_string test_exec_file,
                  "test executable name \
                   (must be absolute, prefixed with ./, or on path)");
                 ("--failed-file", Arg.Set_string test_failed_file,
                  "file in which to dump the failed test case");
                 ("--compiler", Arg.Set_string test_compiler,
                  "compiler name with compilation options");
                 ("--rand-seed", Arg.Set_int randseed,
                  "seed value for random generator");
                 ("--dump-tests", Arg.Set dump_test_cases,
                  "print every test script in compressed form");
                 ("--trace-shrink", Arg.Set trace_shrink,
                  "print intermediate test scripts while shrinking");
                 ("--read-write-invariance", Arg.Set read_write_invariance,
                  "print data in a format that can be fed to ocaml toplevel");
                ] in
  Arg.parse options (fun n -> max_tests := int_of_string n)
    "randomly generate programs using IDA and check if they work as expected";

  Printf.printf "random generator seed value = %d\n" !randseed;
  Random.init !randseed;
  size := 1;
  quickcheck !max_tests

