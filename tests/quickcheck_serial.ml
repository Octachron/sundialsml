module Ida = Ida_serial
module Carray = Ida_serial.Carray
module Roots = Ida.Roots
open Quickcheck
open IdaModel
open Camlp4.PreCast
open Pprint
open Pprint_sundials

(* A state-machine model for IDA sessions.  *)
type session_model =
  {
    resfn : resfn_type;
    mutable solver : Ida.linear_solver;
    mutable consistent : bool;
    mutable t : float;
    mutable roots : float array;
    vec : Carray.t;
    vec' : Carray.t;
    t0 : float;
    vec0 : Carray.t;
    vec'0 : Carray.t;
  }

let copy_resfn = function
  | ResFnLinear slopes -> ResFnLinear (Carray.of_carray slopes)
let copy_model m =
  {
    resfn = copy_resfn m.resfn;
    solver = m.solver;
    t = m.t;
    roots = Array.copy m.roots;
    consistent = m.consistent;
    vec = Carray.of_carray m.vec;
    vec' = Carray.of_carray m.vec';
    t0 = m.t0;
    vec0 = Carray.of_carray m.vec0;
    vec'0 = Carray.of_carray m.vec'0;
  }

let pp_model, dump_model, show_model, display_model,
    print_model, prerr_model
      =
  printers_of_pp
    (let descriptive_fields =
       ["resfn", (fun fmt m -> pp_of_show show_resfn_type fmt m.resfn);
        "solver", (fun fmt m -> pp_of_show show_solver fmt m.solver);
        "roots", (fun fmt m -> pp_array pp_float fmt m.roots);
        "t", (fun fmt m -> pp_float fmt m.t);
        "vec", (fun fmt m -> pp_carray fmt m.vec);
        "vec'", (fun fmt m -> pp_carray fmt m.vec');
        "t0", (fun fmt m -> pp_float fmt m.t0);
        "vec0", (fun fmt m -> pp_carray fmt m.vec0);
        "vec'0", (fun fmt m -> pp_carray fmt m.vec'0);
       ]
     and state_fields =
       ["consistent", (fun fmt m -> pp_bool fmt m.consistent);
       ]
     in
     let rw_invar = pp_record (descriptive_fields @ state_fields)
     and concise = pp_record descriptive_fields in
     fun fmt m ->
       if !read_write_invariance then rw_invar fmt m
       else concise fmt m)

let pp_script, dump_script, show_script, display_script,
    print_script, prerr_script
      =
  printers_of_pp (fun fmt (model, cmds) ->
    Format.fprintf fmt "@[<hov 2>let model =@ ";
    pp_model fmt model;
    Format.fprintf fmt "@]@\n@[<hov 2>let cmds =@ ";
    pp_cmds fmt cmds;
    Format.fprintf fmt "@]@\n@[<hov 2>let script =@ (model, cmds)@]"
  )

(* Find the smallest root(s) in the range (t1..t2].  *)
let find_roots roots t1 t2 =
  let n = Array.length roots in
  if n = 0 then []
  else
    let record  = ref t2
    and holders = ref []
    in
    for i = 0 to n-1 do
      if t1 < roots.(i) && roots.(i) <= !record
      then
        begin
          if roots.(i) < !record then
            (record := roots.(i);
             holders := [i])
          else
            holders := i::!holders
        end
    done;
    !holders

(* The test code is generated by Camlp4 and compiled and run in a separate
   process.  This is done for two reasons:

    - In the worst case, IDA segfaults and this is hard to catch cleanly in
      OCaml.  Running it in a separate process saves the main driver loop from
      crashing together with the test case, so that it can shrink and re-run
      the test case.

    - Once we find a bug, we have to present a test case to the user, and a
      self-contained .ml file is the best way to do it.  So we need code
      generation anyway.  *)

let _loc = Loc.ghost


(* The first few declarations in the generated test code.  *)
let preamble =
  <:str_item<
    module Ida = Ida_serial
    module Carray = Ida.Carray
    open Quickcheck.IdaModel
    open Pprint
    (* Remove error messages so that they don't have to be replicated with 100%
       accuracy in models.  *)
    let nub_exn = function
      | Failure _ -> Failure ""
      | Invalid_argument _ -> Invalid_argument ""
      | exn -> exn
    let marshal_results = ref false
    let print_result thunk =
      (if !marshal_results
       then (fun r -> Marshal.to_channel stdout r [])
       else (fun r -> Printf.printf "%s\\n" (show_result r)))
      (try (Lazy.force thunk)
       with exn -> Exn (nub_exn exn))
    let last_tret = ref 0.
   >>


let semis when_empty ctor = function
  | [] -> when_empty
  | e::es -> ctor (List.fold_left (fun e1 e2 -> Ast.ExSem (_loc, e1, e2)) e es)
let expr_array es = semis <:expr<[||]>> (fun e -> Ast.ExArr (_loc, e)) es
let expr_seq es = semis <:expr<()>> (fun e -> Ast.ExSeq (_loc, e)) es
let expr_of_carray v =
  let n = Carray.length v in
  if n = 0 then <:expr<Carray.create 0>>
  else <:expr<Carray.of_array
              $expr_array (List.map (fun i -> <:expr<$`flo:v.{i}$>>)
                            (enum 0 (n-1)))$>>
let expr_of_linear_solver = function
  | Ida.Dense -> <:expr<Ida.Dense>>
  | Ida.Band range -> <:expr<Ida.Band
                             { Ida.mupper = $`int:range.Ida.mupper$;
                               Ida.mlower = $`int:range.Ida.mlower$; }>>
  | Ida.Sptfqmr _ | Ida.Spbcg _ | Ida.Spgmr _
  | Ida.LapackBand _ | Ida.LapackDense _ ->
    raise (Failure "linear solver not implemented")

let expr_of_resfn neqs = function
  | ResFnLinear slopes ->
    (* forall i. vec.{i} = slopes.{i}*t *)
    let set i = <:expr<res.{$`int:i$}
                         <- vec'.{$`int:i$} -. $`flo:slopes.{i}$>>
    in <:expr<fun t vec vec' res ->
               $expr_seq (List.map set (enum 0 (neqs-1)))$>>
let exact_soln typ t0 vec0 vec'0 t vec vec' =
  match typ with
  | ResFnLinear slopes ->
    for i = 0 to Carray.length vec - 1 do
      vec'.{i} <- slopes.{i};
      vec.{i} <- slopes.{i} *. (t -. t0);
    done
let exact_init model =
  match model.resfn with
  | ResFnLinear slopes ->
    Carray.fill model.vec 0.;
    Carray.fill model.vec0 0.;
    model.consistent <- true

let expr_of_roots roots =
  let n = Array.length roots in
  let set i = <:expr<g.{$`int:i$} <- t -. $`flo:roots.(i)$>> in
  let f ss i = <:expr<$ss$; $set i$>> in
  if n = 0 then <:expr<Ida.no_roots>>
  else <:expr<($`int:n$,
               (fun t vec vec' g ->
                  $Fstream.fold_left f (set 0)
                    (Fstream.enum 1 (n-1))$))>>

let str_item_of_model model =
  <:str_item<
    let vec  = $expr_of_carray model.vec0$
    let vec' = $expr_of_carray model.vec'0$
    let session = Ida.init_at_time
                  $expr_of_linear_solver model.solver$
                  $expr_of_resfn (Carray.length model.vec0) model.resfn$
                  $expr_of_roots model.roots$
                  $`flo:model.t0$
                  vec vec'
    let _ = last_tret := $`flo:model.t$
   >>

(* Generate the test code that executes a given command.  *)
let expr_of_cmd = function
  | SolveNormal dt ->
    <:expr<let tret, flag =
                 Ida.solve_normal session (!last_tret +. $`flo:dt$) vec vec'
           in
           last_tret := tret;
           Aggr [Float tret; SolverResult flag; carray vec; carray vec']>>

(* Run a single command on the model.  *)
let model_cmd model = function
  | SolveNormal dt ->
    (* NB: we don't model interpolation failures -- t will be monotonically
       increasing.  *)
    let t = model.t +. dt in
    if t = model.t0 then Exn Ida.IllInput
    else
      let tret, flag =
        (* NB: roots that the solver is already sitting on are ignored, unless
           dt = 0.  *)
        let tstart = if dt = 0. then model.t -. !discrete_unit else model.t in
        match find_roots model.roots tstart t with
        | i::_ ->
          let tret = model.roots.(i) in
          tret,
          (* If the queried time coincides with a root, then it's reasonable
             for the solver to prioritize either.  In real code, this is most
             likely determined by the state of the floating point error.  *)
          (if tret = t then Type (SolverResult Ida.Continue)
           else SolverResult Ida.RootsFound)
        | _ -> t, SolverResult Ida.Continue
      in
      model.t <- tret;
      exact_soln model.resfn model.t0 model.vec0 model.vec'0
                             model.t  model.vec  model.vec';
      Aggr [Float model.t; flag; carray model.vec; carray model.vec']

(* Run a list of commands on the model.  *)
let model_run (model, cmds) =
  let model = copy_model model in
  (* Evaluation order requires this let here.  *)
  let head = Aggr [Float model.t;
                   carray model.vec;
                   carray model.vec']
  in head :: List.map (model_cmd model) cmds

let expr_of_cmds = function
  | [] -> <:expr<()>>
  | cmds ->
  <:expr<
    Array.iter print_result
    $expr_array (List.map (fun cmd -> <:expr<lazy $expr_of_cmd cmd$>>) cmds)$
    >>

(* Test case generation.  *)

let gen_vec neqs = Carray.of_array (gen_array ~size:neqs gen_discrete_float)

let gen_resfn neqs =
  gen_choice
    [|
      fun () -> let v = Carray.create neqs in
                for i = 0 to Carray.length v - 1 do
                  v.{i} <- float_of_int i
                done;
                ResFnLinear v
    |]
    ()

let gen_solver lapack neqs =
  match Random.int 1 with
  | 0 -> if lapack && Random.bool () then Ida.LapackDense else Ida.Dense
  | _ -> assert false

let init_vec_for neqs t0 resfn =
  match resfn with
  | ResFnLinear slopes -> Carray.init neqs 0., Carray.of_carray slopes

let gen_roots () =
  (* This is basically just a generator for sorted float arrays, but since
     empty root functions are an important special case, we make sure 1/3 of
     the time the generated array is empty.  *)
  match Random.int 3 with
  | 0 -> [||]
  | _ -> gen_array (fun () -> abs_float (gen_discrete_float ()))

let gen_model () =
  let neqs  = min 10 (gen_pos_int ()) in
  let resfn = gen_resfn neqs in
  let t0 = gen_discrete_float () in
  let vec0, vec'0  = init_vec_for neqs t0 resfn in
  let neqs  = Carray.length vec0 in
  {
    resfn = resfn;
    solver = gen_solver false neqs;
    t = t0;
    consistent = true;
    roots = gen_roots ();
    vec   = Carray.of_carray vec0;
    vec'  = Carray.of_carray vec'0;
    t0 = t0;
    vec0  = vec0;
    vec'0 = vec'0;
  }

let gen_cmd =
  let cases =
    [|fun () -> SolveNormal (abs_float (gen_discrete_float ()))|]
  in
  fun () -> gen_choice cases ()
let gen_cmds () = gen_list gen_cmd


(* Fix the generated script so that it's reasonably sane.  Right now, the
   fix-ups performed are:

 *)
let fixup_script (model, cmds) =
  (* We do a dry run of the model, calling a bunch of fix-up functions before
     executing each command.  The fix-up functions can use a model as a
     reference to determine if the command is legitimate or is in need of
     fixing.  *)
  let rec go fs processed model = function
    | cmd::cmds -> let cmd = List.fold_left (fun c f -> f model c) cmd fs in
                   ignore (model_cmd model cmd);
                   go fs (cmd::processed) model cmds
    | [] -> List.rev processed
  in
  let fixup_time model = function
    | SolveNormal t -> SolveNormal (model.t
                                    +. (max (abs_float t) !discrete_unit))
  in
  (model, go [] [] (copy_model model) cmds)

let gen_script () =
  let model = gen_model ()
  and cmds  = gen_cmds ()
  in fixup_script (model, cmds)

(* Shrinking *)
let shrink_neqs model cmds =
  (* Reduce commands that are dependent on number of equations.  *)
  let drop_from_cmd i = function
    | cmd -> cmd
  in
  let copy_vec_drop i v =
    let n = Carray.length v in
    let w = Carray.create (n-1) in
    for j = 0 to i-1 do
      w.{j} <- v.{j}
    done;
    for j = i+1 to n - 1 do
      w.{j-1} <- v.{j}
    done;
    w
  in
  let copy_resfn_drop i = function
    | ResFnLinear slopes -> ResFnLinear (copy_vec_drop i slopes)
  in
  let drop_eq i =
    let model =
      {
        resfn = copy_resfn_drop i model.resfn;
        roots = Array.copy model.roots;
        consistent = model.consistent;
        vec = copy_vec_drop i model.vec;
        vec' = copy_vec_drop i model.vec';
        t0 = model.t0;
        vec0 = copy_vec_drop i model.vec0;
        vec'0 = copy_vec_drop i model.vec'0;
        solver = model.solver;
        t = model.t;
      }
    in (model, List.map (drop_from_cmd i) cmds)
  in
  let n = Carray.length model.vec in
  Fstream.guard (n > 1) (Fstream.map drop_eq (Fstream.enum 0 (n - 1)))

let shrink_root_dir = function
  | Roots.Rising -> Fstream.nil
  | Roots.Falling -> Fstream.singleton Roots.Rising
  | Roots.NoRoot -> assert false

let shrink_model model cmds =
  let update_roots model roots =
    { model with roots = roots }
  in
  Fstream.map (fun t -> ({ model with t = t; t0 = t; }, cmds))
    (shrink_discrete_float model.t)
  @@ Fstream.map (fun roots -> (update_roots model roots, cmds))
    (shrink_array shrink_float model.roots)

let shrink_cmd = function
  | SolveNormal dt ->
    Fstream.map (fun dt -> SolveNormal dt) (shrink_discrete_float dt)

let shrink_script (model, cmds) =
  shrink_neqs model cmds
  @@ shrink_model model cmds
  @@ Fstream.map (fun cmds -> (model, cmds)) (shrink_list shrink_cmd cmds)

(* Code generation options *)
let test_exec_file = ref "./tmp"
let test_compiler =
  ref "ocamlc -g -I .. bigarray.cma unix.cma sundials_ida.cma \
       fstream.cmo pprint.cmo pprint_sundials.cmo quickcheck.cmo"
let test_failed_file = ref "./failed.ml"

(* Generate test code, run it, and return a stream of responses.  *)
let compile (model, cmds) =
  let open Camlp4.PreCast.Printers.OCaml in
  let test_src_file = !test_exec_file ^ ".ml" in
  print_implem ~output_file:test_src_file
    <:str_item<
      $preamble$
      $str_item_of_model model$
      let test () =
         print_result (lazy (Aggr [Float (Ida.get_current_time session);
                                   carray vec; carray vec']));
         $expr_of_cmds cmds$
      let _ =
        Arg.parse
          [("--marshal-results", Arg.Set marshal_results,
            "For internal use only");
           ("--read-write-invariance", Arg.Set read_write_invariance,
            "print data in a format that can be fed to ocaml toplevel")]
          (fun _ -> ()) "a test case generated by quickcheck";
        test ()
    >>;
  let compile_command =
    !test_compiler ^ " -o " ^ !test_exec_file ^ " " ^ test_src_file
  in
  match Unix.system compile_command with
  | Unix.WEXITED 0 -> ()
  | Unix.WEXITED _ | Unix.WSIGNALED _ | Unix.WSTOPPED _ ->
    raise (Failure ("Internal error: generated code failed to compile.  \
                     Compilation command was: " ^ compile_command))

let compile_run script =
  compile script;
  let (pipe_stdout, pipe_stdin, pipe_stderr) as pipes =
    Unix.open_process_full
      (!test_exec_file ^ " --marshal-results")
      (Unix.environment ())
  in
  let recv () =
    try Some (Marshal.from_channel pipe_stdout : result)
    with End_of_file -> (ignore (Unix.close_process_full pipes); None)
  in
  Fstream.to_list (Fstream.generate recv)

(* Run the model and the actual code and check if their results agree.  *)
let compare_runs script =
  let ms0 = model_run script
  and cs0 = compile_run script in
  let rec cmp i ms cs =
    match ms, cs with
    | [], [] -> OK
    | m::ms, c::cs ->
      if result_matches m c then cmp (i+1) ms cs
      else Failed (ResultMismatch (i, m, c))
    | _::_, [] ->
      Failed (TestCodeDied ms)
    | [], _::_ ->
      Failed TestCodeOverrun
  in
  cmp 0 ms0 cs0

let trace_shrink = ref false
let dump_test_cases = ref false

let shrink script reason =
  if !trace_shrink then print_char '\n';
  let rec go ct script reason =
    let failure script =
      let res = compare_runs script in
      if !trace_shrink then
        (Printf.printf "Trying: %s\n-> %s\n"
           (show_script script)
           (if res <> OK then "triggers bug"
            else "not a counterexample");
         flush stdout);
      match res with
      | OK -> None
      | Failed reason -> Some (script, reason)
    in
    match Fstream.find_some failure (shrink_script script) with
    | None -> (ct, script, reason)
    | Some (script, reason) -> go (ct+1) script reason
  in go 0 script reason

let test_script script =
  if !dump_test_cases then
    (Printf.printf "Testing: %s\n" (show_script script); flush stdout);
  match compare_runs script with
  | OK -> true
  | Failed reason ->
    Printf.fprintf stderr "\nFailed!  Shrinking..."; flush stderr;
    let (ct, ((model, cmds) as script), reason) = (shrink script reason) in
    Printf.fprintf stderr
      " %d shrinks.\nFailed test code saved in %s.\n\n[Reason]\n"
      ct
      !test_failed_file;
    (* The test file contains the last script tried, not the last script that
       failed.  We need to update it.  *)
    compile script;
    (match reason with
       | TestCodeDied rs ->
         Printf.fprintf stderr "Test code exited unexpectedly.  It was \
                                supposed to produce the following additional \
                                results:\n";
         prerr_results rs
       | TestCodeOverrun -> assert false (* Shouldn't happen.  *)
       | ResultMismatch (i,e,a) ->
         Printf.fprintf stderr "Result mismatch on %s:\n\
                                expected\n%s\nbut got\n%s\n"
           (if i = 0 then "init" else ("step " ^ string_of_int i))
           (show_result e)
           (show_result a));
    Printf.fprintf stderr "\n[Test Case]\n";
    prerr_string (show_script script);
    Printf.fprintf stderr "\n\n[Program Output]\n";
    flush stderr;
    flush stdout;
    let pid = Unix.create_process !test_exec_file
      (if !read_write_invariance
       then [|!test_exec_file; "--read-write-invariance"|]
       else [|!test_exec_file|])
      Unix.stdin Unix.stdout Unix.stderr
    in
    let _ = Unix.waitpid [] pid in
    let infile  = open_in (!test_exec_file ^ ".ml")
    and outfile = open_out !test_failed_file in
    let _ =
      try while true do output_char outfile (input_char infile) done
      with End_of_file -> ()
    in
    Printf.fprintf stderr "\n\n[Expected Output]\n";
    prerr_results (model_run script);
    false

let quickcheck max_tests =
  let rec go = function
    | 0 -> Printf.printf "\n+++ OK, passed %d tests." max_tests; None
    | tests ->
      let script = gen_script () in
      if test_script script then
        (print_char '*';
         flush stdout;
         size := !size+1;
         go (tests-1))
      else Some script
  in go (max 0 max_tests)

let _ =
  let _ = Random.self_init () in
  let randseed = ref (Random.int ((1 lsl 30) - 1)) in
  let max_tests = ref 50 in
  let options = [("--exec-file", Arg.Set_string test_exec_file,
                  "test executable name \
                   (must be absolute, prefixed with ./, or on path)");
                 ("--failed-file", Arg.Set_string test_failed_file,
                  "file in which to dump the failed test case");
                 ("--compiler", Arg.Set_string test_compiler,
                  "compiler name with compilation options");
                 ("--rand-seed", Arg.Set_int randseed,
                  "seed value for random generator");
                 ("--dump-tests", Arg.Set dump_test_cases,
                  "print every test script in compressed form");
                 ("--trace-shrink", Arg.Set trace_shrink,
                  "print intermediate test scripts while shrinking");
                 ("--read-write-invariance", Arg.Set read_write_invariance,
                  "print data in a format that can be fed to ocaml toplevel");
                ] in
  Arg.parse options (fun n -> max_tests := int_of_string n)
    "randomly generate programs using IDA and check if they work as expected";

  Printf.printf "random generator seed value = %d\n" !randseed;
  Random.init !randseed;
  size := 1;
  quickcheck !max_tests

