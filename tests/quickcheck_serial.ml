module Ida = Ida_serial
module Carray = Ida_serial.Carray
open Quickcheck
open IdaModel
open Camlp4.PreCast

(* A state-machine model for IDA sessions.  *)
type session_model =
  {
    resfn : resfn_type;
    mutable solver : Ida.linear_solver;
    mutable consistent : bool;
    mutable t : float;
    vec : Carray.t;
    vec' : Carray.t;
    t0 : float;
    vec0 : Carray.t;
    vec'0 : Carray.t;
  }

let copy_resfn = function
  | ResFnLinear slopes -> ResFnLinear (Carray.of_carray slopes)
let copy_model m =
  {
    resfn = copy_resfn m.resfn;
    solver = m.solver;
    t = m.t;
    consistent = m.consistent;
    vec = Carray.of_carray m.vec;
    vec' = Carray.of_carray m.vec';
    t0 = m.t0;
    vec0 = Carray.of_carray m.vec0;
    vec'0 = Carray.of_carray m.vec'0;
  }

(* Commands that can be sent to IDA sessions and their return values.  *)

type script = session_model * cmd list

let show_model model =
  Printf.sprintf "{ resfn = %s; solver = %s; roots = %s; \
                    t = %s; vec = %s; vec' = %s; \
                    t0 = %s; vec0 = %s; vec'0 = %s; consistent = %s }"
    (show_resfn_type model.resfn)
    (show_solver model.solver)
    (show_array string_of_float model.roots)
    (show_float model.t)
    (show_carray model.vec)
    (show_carray model.vec')
    (show_float model.t0)
    (show_carray model.vec0)
    (show_carray model.vec'0)
    (string_of_bool model.consistent)
let dump_model model =
  with_read_write_invariance (fun () -> show_model model)

let show_script (model, cmds) =
  Printf.sprintf "(%s, %s)"
    (show_model model)
    (show_cmds cmds)

let dump_script (model, cmds) =
  Printf.sprintf "(%s, %s)"
    (dump_model model)
    (show_cmds cmds)

let _loc = Loc.ghost

(* The test code is generated by Camlp4 and compiled and run in a separate
   process.  This is done for two reasons:

    - In the worst case, IDA segfaults and this is hard to catch cleanly in
      OCaml.  Running it in a separate process saves the main driver loop from
      crashing together with the test case, so that it can shrink and re-run
      the test case.

    - Once we find a bug, we have to present a test case to the user, and a
      self-contained .ml file is the best way to do it.  So we need code
      generation anyway.  *)

(* The first few declarations in the generated test code.  *)
let preamble =
  <:str_item<
    module Ida = Ida_serial
    module Carray = Ida.Carray
    open Quickcheck.IdaModel
    (* Remove error messages so that they don't have to be replicated with 100%
       accuracy in models.  *)
    let nub_exn = function
      | Failure _ -> Failure ""
      | Invalid_argument _ -> Invalid_argument ""
      | exn -> exn
    let marshal_results = ref false
    let print_result thunk =
      (if !marshal_results
       then (fun r -> Marshal.to_channel stdout r [])
       else (fun r -> Printf.printf "%s\\n" (show_result r)))
      (try (Lazy.force thunk)
       with exn -> Exn (nub_exn exn))
   >>


let semis when_empty ctor = function
  | [] -> when_empty
  | e::es -> ctor (List.fold_left (fun e1 e2 -> Ast.ExSem (_loc, e1, e2)) e es)
let expr_array es = semis <:expr<[||]>> (fun e -> Ast.ExArr (_loc, e)) es
let expr_seq es = semis <:expr<()>> (fun e -> Ast.ExSeq (_loc, e)) es
let expr_of_carray v =
  let n = Carray.length v in
  if n = 0 then <:expr<Carray.create 0>>
  else <:expr<Carray.of_array
              $expr_array (List.map (fun i -> <:expr<$`flo:v.{i}$>>)
                            (enum 0 (n-1)))$>>
let expr_of_linear_solver = function
  | Ida.Dense -> <:expr<Ida.Dense>>
  | Ida.Band range -> <:expr<Ida.Band
                             { Ida.mupper = $`int:range.Ida.mupper$;
                               Ida.mlower = $`int:range.Ida.mlower$; }>>
  | Ida.Sptfqmr _ | Ida.Spbcg _ | Ida.Spgmr _
  | Ida.LapackBand _ | Ida.LapackDense _ ->
    raise (Failure "linear solver not implemented")

let expr_of_resfn neqs = function
  | ResFnLinear slopes ->
    (* forall i. vec.{i} = slopes.{i}*t *)
    let set i = <:expr<res.{$`int:i$}
                         <- vec'.{$`int:i$} -. $`flo:slopes.{i}$>>
    in <:expr<fun t vec vec' res ->
               $expr_seq (List.map set (enum 0 (neqs-1)))$>>
let exact_soln typ t0 vec0 vec'0 t vec vec' =
  match typ with
  | ResFnLinear slopes ->
    for i = 0 to Carray.length vec - 1 do
      vec'.{i} <- slopes.{i};
      vec.{i} <- slopes.{i} *. (t -. t0);
    done
let exact_init model =
  match model.resfn with
  | ResFnLinear slopes ->
    Carray.fill model.vec 0.;
    Carray.fill model.vec0 0.;
    model.consistent <- true

(* Generate the test code that executes a given command.  *)
let expr_of_cmd = function
  | SolveNormal t ->
    <:expr<let (tret, flag) = Ida.solve_normal session $`flo:t$ vec vec' in
           Aggr [Float tret; SolverResult flag; carray vec; carray vec']>>

(* Run commands on the state-machine model.  *)
let model_cmd model = function
  | SolveNormal t ->
      (* NB: we don't model interpolation failures: i.e. t will always be
             increasing throughout the program or decreasing throughout.
             See fixup_script.  *)
      model.t <- t;
      exact_soln model.resfn model.t0 model.vec0 model.vec'0
                             model.t  model.vec  model.vec';
      Aggr [Float model.t; SolverResult Ida.Continue;
            carray model.vec; carray model.vec']
let model_run model cmds =
  let model = copy_model model in
  (* Evaluation order requires this let here.  *)
  let head = Aggr [Float model.t;
                   carray model.vec;
                   carray model.vec']
  in head :: List.map (model_cmd model) cmds

let str_item_of_model model =
  assert (model.t0 = model.t);
  <:str_item<
    let vec  = $expr_of_carray model.vec0$
    let vec' = $expr_of_carray model.vec'0$
    let session = Ida.init_at_time
                  $expr_of_linear_solver model.solver$
                  $expr_of_resfn (Carray.length model.vec0) model.resfn$
                  Ida.no_roots
                  $`flo:model.t$
                  vec vec'
   >>

let expr_of_cmds = function
  | [] -> <:expr<()>>
  | cmds ->
  <:expr<
    Array.iter print_result
    $expr_array (List.map (fun cmd -> <:expr<lazy $expr_of_cmd cmd$>>) cmds)$
    >>

(* Test case generation.  *)

let gen_vec neqs = Carray.of_array (gen_array ~size:neqs gen_discrete_float)

let gen_resfn neqs =
  gen_choice
    [|
      fun () -> let v = Carray.create neqs in
                for i = 0 to Carray.length v - 1 do
                  v.{i} <- float_of_int i
                done;
                ResFnLinear v
    |]
    ()

let gen_solver lapack neqs =
  match Random.int 1 with
  | 0 -> if lapack && Random.bool () then Ida.LapackDense else Ida.Dense
  | _ -> assert false

let init_vec_for neqs t0 resfn =
  match resfn with
  | ResFnLinear slopes -> Carray.init neqs 0., Carray.of_carray slopes

let gen_model () =
  let neqs  = min 10 (gen_pos_int ()) in
  let resfn = gen_resfn neqs in
  let t0 = gen_discrete_float () in
  let vec0, vec'0  = init_vec_for neqs t0 resfn in
  let neqs  = Carray.length vec0 in
  {
    resfn = resfn;
    solver = gen_solver false neqs;
    t = t0;
    consistent = true;
    vec   = Carray.of_carray vec0;
    vec'  = Carray.of_carray vec'0;
    t0 = t0;
    vec0  = vec0;
    vec'0 = vec'0;
  }

let gen_cmd =
  let cases =
    [|fun () -> SolveNormal (gen_discrete_float () +. 0.1)|]
  in
  fun () -> cases.(Random.int (Array.length cases)) ()
let gen_cmds () = gen_list gen_cmd


(* Fix the generated script so that it's reasonably sane.  Right now, the
   fix-ups performed are:

   - Making the solution time queries monotonically increasing and starting at
     somewhere > t0, or monotonically decreasing and starting at < t0.  When
     the queries of SolveNormal increase and then decrease, whether IDA
     successfully interpolates that value depends a lot on its internal state,
     which is too much to model.

 *)
let fixup_script (model, cmds) =
  let direction = if Random.bool () then 1. else -1. in
  (* We do a dry run of the model, calling a bunch of fix-up functions before
     executing each command.  The fix-up functions can use a model as a
     reference to determine if the command is legitimate or is in need of
     fixing.  *)
  let rec go fs processed model = function
    | cmd::cmds -> let cmd = List.fold_left (fun c f -> f model c) cmd fs in
                   ignore (model_cmd model cmd);
                   go fs (cmd::processed) model cmds
    | [] -> List.rev processed
  in
  let fixup_time model = function
    | SolveNormal t -> SolveNormal (model.t
                                    +. (abs_float t +. !discrete_unit)
                                    *. direction)
  in
  (model, go [fixup_time] [] (copy_model model) cmds)

let gen_script () =
  let model = gen_model ()
  and cmds  = gen_cmds ()
  in fixup_script (model, cmds)

(* Shrinking *)
let shrink_neqs model cmds =
  (* Reduce commands that are dependent on number of equations.  *)
  let drop_from_cmd i = function
    | cmd -> cmd
  in
  let copy_vec_drop i v =
    let n = Carray.length v in
    let w = Carray.create (n-1) in
    for j = 0 to i-1 do
      w.{j} <- v.{j}
    done;
    for j = i+1 to n - 1 do
      w.{j-1} <- v.{j}
    done;
    w
  in
  let copy_resfn_drop i = function
    | ResFnLinear slopes -> ResFnLinear (copy_vec_drop i slopes)
  in
  let drop_eq i =
    let model =
      {
        resfn = copy_resfn_drop i model.resfn;
        consistent = model.consistent;
        vec = copy_vec_drop i model.vec;
        vec' = copy_vec_drop i model.vec';
        t0 = model.t0;
        vec0 = copy_vec_drop i model.vec0;
        vec'0 = copy_vec_drop i model.vec'0;
        solver = model.solver;
        t = model.t;
      }
    in (model, List.map (drop_from_cmd i) cmds)
  in
  let n = Carray.length model.vec in
  Stream.guard (n > 1) (Stream.map drop_eq (Stream.enum 0 (n - 1)))

let shrink_model model cmds =
  Stream.map (fun t -> ({ model with t = t; t0 = t; }, cmds))
    (shrink_discrete_float model.t)

let shrink_cmd = function
  | SolveNormal dt ->
    Stream.map (fun dt -> SolveNormal dt) (shrink_discrete_float dt)

let shrink_script (model, cmds) =
  shrink_neqs model cmds
  @@ (shrink_model model cmds)
  @@ Stream.map (fun cmds -> (model, cmds)) (shrink_list shrink_cmd cmds)

(* Code generation options *)
let test_exec_file = ref "./tmp"
let test_compiler = ref "ocamlc -I .. bigarray.cma unix.cma sundials_ida.cma \
                         quickcheck.cmo"
let test_failed_file = ref "./failed.ml"

(* Generate test code, run it, and return a stream of responses.  *)
let compile (model, cmds) =
  let open Camlp4.PreCast.Printers.OCaml in
  let test_src_file = !test_exec_file ^ ".ml" in
  print_implem ~output_file:test_src_file
    <:str_item<
      $preamble$
      $str_item_of_model model$
      let test () =
         print_result (lazy (Aggr [Float (Ida.get_current_time session);
                                   carray vec; carray vec']));
         $expr_of_cmds cmds$
      let _ =
        Arg.parse [("--marshal-results", Arg.Set marshal_results,
                    "For internal use only")]
          (fun _ -> ()) "a test case generated by quickcheck";
        test ()
    >>;
  let compile_command =
    !test_compiler ^ " -o " ^ !test_exec_file ^ " " ^ test_src_file
  in
  match Unix.system compile_command with
  | Unix.WEXITED 0 -> ()
  | Unix.WEXITED _ | Unix.WSIGNALED _ | Unix.WSTOPPED _ ->
    raise (Failure ("Internal error: generated code failed to compile.  \
                     Compilation command was: " ^ compile_command))
let compile_run script =
  compile script;
  let (pipe_stdout, pipe_stdin, pipe_stderr) as pipes =
    Unix.open_process_full
      (!test_exec_file ^ " --marshal-results")
      (Unix.environment ())
  in
  let recv () =
    try Some (Marshal.from_channel pipe_stdout : result)
    with End_of_file -> (ignore (Unix.close_process_full pipes); None)
  in
  Stream.generate recv

let compare_runs (model, cmds) =
  let ms0 = model_run model cmds
  and cs0 = compile_run (model, cmds) in
  let rec cmp i ms cs =
    match ms, cs with
    | [], Stream.Nil -> OK
    | m::ms, Stream.Cons (c,cs) ->
      if results_equal m c then cmp (i+1) ms (Lazy.force cs)
      else Failed (ResultMismatch (i, m, c))
    | _::_, Stream.Nil ->
      Failed (TestCodeDied ms)
    | [], Stream.Cons _ ->
      Failed TestCodeOverrun
  in
  cmp 0 ms0 cs0

let trace_shrink = ref false
let dump_test_cases = ref false

let shrink script reason =
  if !trace_shrink then print_char '\n';
  let rec go ct script reason =
    let failure script =
      let res = compare_runs script in
      if !trace_shrink then
        (Printf.printf "Trying: %s\n-> %s\n"
           (dump_script script)
           (if res <> OK then "triggers bug"
            else "not a counterexample");
         flush stdout);
      match res with
      | OK -> None
      | Failed reason -> Some (script, reason)
    in
    match Stream.find_some failure (shrink_script script) with
    | None -> (ct, script, reason)
    | Some (script, reason) -> go (ct+1) script reason
  in go 0 script reason

let test_script script =
  if !dump_test_cases then
    (Printf.printf "Testing: %s\n" (dump_script script); flush stdout);
  match compare_runs script with
  | OK -> true
  | Failed reason ->
    Printf.fprintf stderr "\nFailed!  Shrinking..."; flush stderr;
    let (ct, ((model, cmds) as script), reason) = (shrink script reason) in
    Printf.fprintf stderr
      " %d shrinks.\nFailed test code saved in %s.\n\n[Reason]\n"
      ct
      !test_failed_file;
    (* The test file contains the last script tried, not the last script that
       failed.  We need to update it.  *)
    compile script;
    (match reason with
       | TestCodeDied rs ->
         Printf.fprintf stderr "Test code exited unexpectedly.  It was \
                                supposed to produce in addition:\n";
         List.iter (fun r -> Printf.fprintf stderr "%s\n" (show_result r)) rs
       | TestCodeOverrun -> assert false (* Shouldn't happen.  *)
       | ResultMismatch (i,e,a) ->
         Printf.fprintf stderr "Result mismatch on %s:\n\
                                expected\n%s\nbut got\n%s\n"
           (if i = 0 then "init" else ("step " ^ string_of_int i))
           (show_result e)
           (show_result a));
    Printf.fprintf stderr "\n[Test Case]\nmodel = %s\ncommands = \n"
      (show_model model);
    let nsteps = List.length cmds in
    let step_width = String.length (string_of_int (nsteps - 1)) in
    let pad_show n = let s = string_of_int n in
                     String.make (step_width - String.length s) ' ' ^ s
    in
    ignore
      (List.fold_left
         (fun i cmd -> 
           Printf.fprintf stderr "step %s: %s\n"
             (pad_show i)
             (show_cmd cmd);
           i+1)
         1
         cmds);
    Printf.fprintf stderr "\n\n[Program Output]\n";
    flush stderr;
    flush stdout;
    let pid = Unix.create_process !test_exec_file [|!test_exec_file|]
      Unix.stdin Unix.stdout Unix.stderr
    in
    let _ = Unix.waitpid [] pid in
    let infile  = open_in (!test_exec_file ^ ".ml")
    and outfile = open_out !test_failed_file in
    let _ =
      try while true do output_char outfile (input_char infile) done
      with End_of_file -> ()
    in
    Printf.fprintf stderr "\n\n[Expected Output]\n";
    List.iter (fun res -> Printf.fprintf stderr "%s\n" (show_result res))
      (model_run model cmds);
    false

let quickcheck max_tests =
  let rec go = function
    | 0 -> Printf.printf "\n+++ OK, passed %d tests." max_tests; None
    | tests ->
      let script = gen_script () in
      if test_script script then
        (print_char '*';
         flush stdout;
         size := !size+1;
         go (tests-1))
      else Some script
  in go (max 0 max_tests)

let _ =
  let _ = Random.self_init () in
  let randseed = ref (Random.int ((1 lsl 30) - 1)) in
  let max_tests = ref 50 in
  let options = [("--exec-file", Arg.Set_string test_exec_file,
                  "test executable name \
                   (must be absolute, prefixed with ./, or on path)");
                 ("--failed-file", Arg.Set_string test_failed_file,
                  "file in which to dump the failed test case");
                 ("--compiler", Arg.Set_string test_compiler,
                  "compiler name with compilation options");
                 ("--rand-seed", Arg.Set_int randseed,
                  "seed value for random generator");
                 ("--dump-tests", Arg.Set dump_test_cases,
                  "print every test script in compressed form");
                 ("--trace-shrink", Arg.Set trace_shrink,
                  "print intermediate test scripts while shrinking");
                ] in
  Arg.parse options (fun n -> max_tests := int_of_string n)
    "randomly generate programs using IDA and check if they work as expected";

  Printf.printf "random generator seed value = %d\n" !randseed;
  Random.init !randseed;
  size := 1;
  quickcheck !max_tests

